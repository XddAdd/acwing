# 树2

leetcode树2

# 865.具有所有最深节点的最小子树

![image-20210602095018146](https://gitee.com/xddadd/cloud-image/raw/master/image-20210602095018146.png)

![image-20210602095025394](https://gitee.com/xddadd/cloud-image/raw/master/image-20210602095025394.png)

![image-20210602095037323](https://gitee.com/xddadd/cloud-image/raw/master/image-20210602095037323.png)

## 递归+分类讨论

> 从样例中发现，我们要遍历到最下面的节点，为了判断深度，需要知道下面节点的深度，还得返回下面节点的父节点，所以我们遍历的时候需要携带深度和最深节点的父节点

对于某个节点p来说，左子树是l，右子树是r

- 若p为空，则深度为0
- 若l深度和r深度一样，返回当前节点p，深度返回任意一个+1
- 若l深度>r深度，返回左边答案，深度返回l深度+1
- 若l深度<r深度，返回右边答案，深度返回r深度+1

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<TreeNode*, int> dfs(TreeNode* root) {
        if (!root) return {nullptr, 0};
        auto l = dfs(root->left), r = dfs(root->right);
        if (l.second == r.second) return {root, l.second + 1};
        if (l.second > r.second) return {l.first, l.second + 1};
        return {r.first, r.second + 1};
    }


    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        return dfs(root).first;
    }
};
```

# 241.为运算表达式设计优先级

![image-20210604125640207](https://gitee.com/xddadd/cloud-image/raw/master/image-20210604125640207.png)

## 树的中序遍历+递归

> 中缀表达式可以转化成一个树，叶节点放数字，非叶节点放运算符。
>
> 将整个表达式看成是不同树的中序遍历的结果。加括号只不过是改变树的形态，不影响中序遍历的结果，这样我们就可以任意的枚举每个运算符作为树的根节点。类似**lc95题**

1. 枚举表达式。
2. 如果遇到运算符，就可以将该运算符看成树的根节点，先处理左右两边能得到的所有结果，然后进行乘法原理进行组合结果。
3. 最终若答案数组为0，则说明表达式只有一个数字，无运算符。

时间复杂度$O(C_N)$

## AC代码

```cpp
class Solution {
public:
    vector<int> diffWaysToCompute(string exp) {
        int n = exp.size();
        vector<int> res;
        for (int i = 0 ; i < n ; i ++) {
            char c = exp[i];
            if (c == '+' || c == '-' || c == '*') {
                auto left = diffWaysToCompute(exp.substr(0, i));
                auto right = diffWaysToCompute(exp.substr(i + 1, n - i - 1));
                for (auto a : left) 
                    for (auto b : right) {
                        if (c == '+') res.push_back(a + b);
                        else if (c == '-') res.push_back(a - b);
                        else res.push_back(a * b);
                    }
            }
        }
        //特判表达式只有数字
        if (res.size() == 0) res.push_back(stoi(exp.substr(0)));
        return res;
    }
};
```

# 331.验证二叉树的前序序列化

![image-20210607105004650](https://gitee.com/xddadd/cloud-image/raw/master/image-20210607105004650.png)

## 模拟dfs递归

模拟一下前序遍历树

先给字符串后面加个`,`

- 如果递归到k == s.size()了，一定不合法
- 如果遇到空节点，认为是合法的，k+=2后返回true
- 否则是普通的节点，跳过该节点(相当于遍历过)，递归左子树和右子树

如果dfs是不合法的，一定不合法，如果dfs合法，那么要判断k是否遍历完该树了，即k == s.size()

时间复杂度$O(N)$

## AC代码

```cpp
class Solution {
public:
    int k;
    string s;

    bool isValidSerialization(string str) {
        k = 0;
        s = str + ",";
        if (!dfs()) return false;
        return k == s.size();
    }

    bool dfs() {
        if (k == s.size()) return false;
        if (s[k] == '#') return k += 2, true;
        while (s[k] != ',') k ++;
        k ++;
        return dfs() && dfs();
    }
    
};
```

# 700.二叉搜索树中的搜索

![image-20210618185407864](https://gitee.com/xddadd/cloud-image/raw/master/image-20210618185407864.png)

## 二叉搜索树查找

该题是数据结构课中二叉搜索数(BST)的查找的一个操作。

> 二叉搜索树的特点：
>
> 每个节点的值都比左子树任何一个节点的值大，都比右子树任何一个节点小

1. 从root开始遍历
2. 若$target == now$，则说明已经找到了以target为根的子树，返回即可
3. 若$target<now$，因为now和now的右子树都是>target，则一定不在now的右子树，则now = now->left
4. 否则，说明now一定在now的左子树里面

都找不到最终now会变成空，返回即可。

时间复杂度$O(N)$

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int target) {
        while (root) {
            if (root->val == target) return root;
            else if (root->val < target) root = root->right;
            else root = root->left;
        }
        return root;
    }
};
```

