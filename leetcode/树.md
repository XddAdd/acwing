# 树

Leetcode上面关于树类型的题总结

# 94. 二叉树的中序遍历

![image-20201110144251637](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110144251637.png)

![image-20201110144257359](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110144257359.png)

## 二叉树的遍历

二叉树的前序遍历是根左右，中序遍历是左根右，后序遍历是左右根，一般前面三种遍历都是递归写法，也可以用迭代。层序遍历是一层一层的遍历，需要利用数据结构队列。

## 递归写法

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }

    void dfs(TreeNode* root){
        if (!root) return;
        dfs(root->left);
        ans.push_back(root->val);
        dfs(root->right);
    }
};
```

## 非递归写法

- 遇到一个节点，就把它**压栈**，并去遍历它的**左子树**
- 当**左子树遍历结束**后，从栈顶弹出这个结点并**访问**它
- 然后按其右指针再去中序遍历该结点的**右子树**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        //终止条件,root为空并且栈空
        while (root || stk.size()){
            //遇到节点，压栈并去遍历其左子树
            while (root){
                stk.push(root);
                root = root->left;
            }
            //左子树遍历结束，栈顶弹出并访问
            if (stk.size()){
                root = stk.top();
                stk.pop();
                res.push_back(root->val);
                //按其右指针继续去中序遍历
                root = root->right;
            }
        }

        return res;
    }


    
};
```

# 95. 不同的二叉搜索树 ||

![image-20201110153808532](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110153808532.png)

## 利用二叉搜索树中序遍历有序性

![image-20201110162910640](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110162910640.png)

我们可以得出一个有序的序列中，如果把该序列当成二叉搜索树，那么对于如果我们把该序列的任何一个点看成根节点的话，在该点左边的数，在二叉搜索树里面就是该点的左子树,在该点左边的数，在二叉搜索树里面就是该点的右子树。再将问题细小化，左边的序列再去枚举......**子问题的划分，这不是递归吗？**

**时间复杂度**

![image-20201110162927506](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110162927506.png)



证明略，该时间复杂度是**指数级别**。

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        //特判n=0
        if (!n) return {};
        return dfs(1, n);
    }

    vector<TreeNode*> dfs(int l , int r){
        if (l > r) return {NULL};//终止条件
        vector<TreeNode*> res;
        //枚举[l,r]中每个点作为根节点
        for (int i = l ; i <= r ; i ++){
            auto left = dfs(l, i - 1) , right = dfs(i + 1, r);
            //将左子树节点和右子树节点拼接
            for (auto l : left){
                for (auto r : right){
                    auto root = new TreeNode(i);
                    root->left = l , root->right = r;
                    res.push_back(root);
                }
            }
        }

        return res;
    }
};
```

# 96.不同的二叉搜索树 

![image-20201110163305831](https://gitee.com/xddadd/cloud-image/raw/master/image-20201110163305831.png)

## 二叉搜索树中序遍历有序性

该题和95题是一个题，该题是求方案数，95题是求所有方案

![image-20201111103202347](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111103202347.png)

**即序列个数相同组成的二叉搜索树方案数相同**

和上题一样，我们可以枚举序列的每个点作为根结点，左子树和右子树能够组成多少方案，由于有了上面的第二个性质，即相同序列组成的二叉搜索树方案相同，我们可以用动态规划的思想来求。

![image-20210317173651125](https://gitee.com/xddadd/cloud-image/raw/master/image-20210317173651125.png)

**状态表示：** f[i]表示i个结点组成二叉搜索树的方案数。
**状态方程** `f[i] = f[i - 1 - l + 1] * f[r - i - 1 + 1]`
递归公式：![image-20201111103240001](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111103240001.png)

**时间复杂度O(N^2^)，空间复杂度O(N)**

**代码：**

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> f(n + 1);
        f[0] = 1;
        for (int i = 1 ; i <= n ; i++)
            for (int j = 1 ; j <= i ; j ++)
                f[i] += f[j - 1] * f[i - j];

        return f[n];
    }
};
```

# 98. 验证二叉搜索树

![image-20201111103329634](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111103329634.png)

## 二叉搜索树中序遍历有序性

求得二叉搜索树的中序遍历的结果，再去验证该结果是否是有序的。

**时间复杂度O(N) , 空间复杂度O(N)**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> in_order;//记录中序遍历结果
    bool isValidBST(TreeNode* root) {
        //特判树空
        if (!root) return true;
        //求树的中序遍历
        dfs(root);
        //验证中序遍历序列是否有序
        for (int i = 0 ; i < in_order.size() ; i ++)
            if (i && in_order[i - 1] >= in_order[i]) 
                return false;

        return true;
    }

    void dfs(TreeNode* root){
        if (!root) return ;
        dfs(root->left);
        in_order.push_back(root->val);
        dfs(root->right);
    }

};
```

## 中序遍历中验证是否满足二叉搜索树的性质

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

在遍历过程中求一下每个子树的最小值和最大值即可。对于左子树来说，要求得最大值，对于右子树来说，要求最小值。

**时间复杂度O(N)，空间复杂度O(H)，H为树的高度**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) :
            val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        //特判空树
        if (!root) return true;
        int maxt, mint;
        return dfs(root, maxt, mint);
    }

    bool dfs(TreeNode* root, int &maxt, int &mint)
    {
        maxt = mint = root->val;
        //验证左子树
        if (root->left)
        {
            int lmax, lmin;
            if (!dfs(root->left, lmax, lmin))
                return false;
            if (lmax >= root->val)
                return false;
            maxt = max(maxt, lmax);
            mint = min(mint, lmin);
        }
        //验证右子树
        if (root->right)
        {
            int rmax, rmin;
            if (!dfs(root->right, rmax, rmin))
                return false;
            if (rmin <= root->val)
                return false;
            maxt = max(maxt, rmax);
            mint = min(mint, rmin);
        }
        return true;
    }
};

```

# 100. 相同的树

![image-20201111200509644](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111211753931.png)

## 递归

对于两棵树来说，不仅要结构相同，还要各个结点相同。

使用递归求解

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        //树都空
        if (!q && !p) return true;
        //树其中一个不空
        if (!q || !p) return false;
        //当前节点值不同
        if (q->val != p->val) return false;
        //左子树和右子树的判断
        return isSameTree(p->left, q->left) && isSameTree(p->right , q->right);
    }
};
```

# 101. 对称二叉树

![image-20201111211839199](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111200509644.png)



## 解题

和100题差不多

![image-20201111211753931](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111211839199.png)

我们需要先判断根节点，再去看左子树和右子树的情况。

- 左子树的结点和右子树结点都空，说明对称
- 左子树和右子树其中一个空，说明不对称
- 左子树和右子树结点的值不同，说明不对称
- 递归的去看左子树的左边和右子树的右边  并且 递归的去看右子树的左边和左子树的右边

**时间复杂度O(N)，空间复杂度O(H)，H为树的高度**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        //空树
        if (!root) return true;
        return dfs(root->left, root->right);
    }

    bool dfs(TreeNode* t1, TreeNode* t2){
        //左子树结点和右子树结点都空
        if (!t1 && !t2) return true;
        //其中一个不空
        if (!t1 || !t2) return false;
        //结点值不同
        if (t1->val != t2->val) return false;
        //递归左子树，右子树
        return dfs(t1->left, t2->right) && dfs(t1->right, t2->left);
    }
};
```

# 102. 二叉树的层序遍历

![image-20201111213801058](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111213801058.png)

## 层序遍历

利用队列来实现层序遍历

该题不仅要层序遍历，还要求每个结点是哪层的。稍有扩展。

**时间复杂度O(N)，空间复杂度O(N)**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.push(root);

        while (q.size()){
            vector<int> level;
            //获取当前层结点数
            int len = q.size();
            //扫描该层的所有结点
            for (int i = 0; i < len ; i++){
                auto t = q.front();
                q.pop();
                level.push_back(t->val);
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
            //加入答案
            res.push_back(level);
        }

        return res;

    }
};
```

# 103. 二叉树的锯齿形层次遍历

![image-20201111220145423](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111220145423.png)

## 二叉树的层序遍历

该题是类似S型的遍历，对于S型的遍历，**如果把根节点看成第0层，我们可以发现，偶数层是从左到右，奇数层是从右到左的**。

**时间复杂度O(N)**

**代码：**

下面的代码只是在102题的代码加了注释下面的判断当前层是否是奇数层

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.push(root);

        while (q.size()){
            vector<int> level;
            int len = q.size();

            for (int i = 0 ; i < len ; i ++){
                auto t = q.front();
                q.pop();
                level.push_back(t->val);
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
            //判断当前层是否是奇数层
            if (res.size() & 1) reverse(level.begin(), level.end());
            res.push_back(level);
        }

        return res;
    }
};
```

# 104. 二叉树的最大深度

![image-20201111220615375](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111220615375.png)

## dfs一行代码

**时间复杂度O(N)，空间复杂度(H)，H树的高度**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
    	//只需要下面一行
        return root ? max(maxDepth(root->left),maxDepth(root->right)) + 1 : 0;
    }
};

```

## 层序遍历求深度

**时间复杂度O(N)，空间复杂度O(L)，L为每层最大的个数**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q;
        if (root) q.push(root);
        int dep = 0;
        while (q.size()){
            dep ++;
            int len = q.size();
            for (int i = 0 ; i < len ; i ++){
                auto t = q.front();
                q.pop();
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
        }

        return dep;
    }


};
```

# 105. 从前序与中序遍历序列构造二叉树(经典)

![image-20201111230302321](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111230302321.png)

## 前序中序建树

前序：根左右
中序：左根右

前序遍历的第一个结点是根节点，我们不能判断后面的序列哪些是左子树，哪些是右子树，我们需要确定数量。所以去中序遍历中找到根节点所在的位置，这样能够确定左子树结点个数，这样右子树结点个数也能确定了，再去确定左子树的结构和右子树的结构即可。

![image-20201111235255393](https://gitee.com/xddadd/cloud-image/raw/master/image-20201111235255393.png)

**时间复杂度O(N)**

**代码:**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //哈希表，记录中序遍历每个元素在中序序列的位置
    unordered_map<int,int> hash;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        //空树
        if (!preorder.size()) return NULL;
        //中序序列插入哈希表
        for (int i = 0 ; i < inorder.size() ; i ++) hash[inorder[i]] = i;
        //建树
        return build(preorder, inorder, 0, preorder.size() -1 , 0 , inorder.size() -1 );
    }

    TreeNode* build(vector<int>& pre, vector<int>& inorder,  int pl, int pr, int inl, int inr){
        //递归终止
        if (pl > pr) return NULL;
        //创建根节点
        auto root = new TreeNode(pre[pl]);
        //根节点在中序遍历的位置
        int k = hash[root->val];
        //建左子树
        root->left = build(pre, inorder, pl + 1, pl + 1 + k - 1 - inl, inl, k -1);
        //建右子树
        root->right = build(pre, inorder, pl + 1 + k - 1 - inl + 1, pr, k + 1, inr);

        return root;
    }
};
```

# 106. 从中序与后序遍历序列构造二叉树

![image-20201112000125422](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112000125422.png)

## 中序后序建树

和105题是类似的

后序：左右根
中序：左根右

![image-20201112000210782](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112000210782.png)

后序遍历的最后一个结点是根节点，再去中序遍历找到该点，中序遍历左边的结点就是左子树，右边就是右子树。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> hash;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //特判空树
        if (!inorder.size()) return NULL;
        //中序序列的值和下标映射
        for (int i = 0 ; i < inorder.size() ; i ++) hash[inorder[i]] = i;
        return build(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
    }

    TreeNode* build(vector<int>& inorder, vector<int>& post, int inl, int inr, int pl, int pr){
        //递归终止条件
        if (inl > inr) return NULL;
        //创建根节点
        auto root = new TreeNode(post[pr]);
        //根节点在中序遍历的位置
        int k = hash[root->val];
        //建左子树
        root->left = build(inorder, post, inl, k - 1, pl , pl + k - inl - 1 );
        //建右子树
        root->right = build(inorder, post, k + 1, inr, pl + k - inl - 1 + 1, pr - 1);

        return root;
    }
};
```

# 107.二叉树的层次遍历 ||

![image-20201112005856085](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112005856085.png)

## 树的层序遍历

和102题一毛一样，只不过是要求从下面开始遍历

我们只需要将层序遍历的结果翻转一下就可以得到从下面开始遍历的结果。

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.push(root);

        while (q.size()){
            vector<int> level;
            int len = q.size();
            for (int i = 0 ; i < len ; i ++){
                auto t = q.front();
                q.pop();
                level.push_back(t->val);
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
            res.push_back(level);
        }
        reverse(res.begin() , res.end());
        return res;
    }
};
```

# 108. 将有序数组转换成二叉搜索树

![image-20201112100834638](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112104027939.png)

## 递归建树

我们都知道有序数组的中序遍历有序，如果我们要建一颗二叉搜索树，还想尽量成为二叉平衡树，我们就必须要选择序列中中间的数，这样左边就是左子树，右边是右子树，能够使得左右两边尽量均匀。

**时间复杂度O(N)**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0 , nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int l ,int r){
        //递归终止条件
        if (l > r) return NULL;
        //取序列中间作为根节点
        int mid = l + r >> 1;
        auto root = new TreeNode(nums[mid]);
        //递归去建左子树和右子树
        root->left = build(nums, l, mid - 1);
        root->right = build(nums, mid + 1, r);

        return root;
    }
};
```

# 109.有序链表转换成二叉搜索树

![image-20201112104027939](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112115952485.png)

## 单链表转二叉树

108题是数组转平衡二叉搜索树，该题是将数组变成了单链表的结构。

思路和上题一样：

找到中点作为根节点，递归的建左子树和右子树。

我们直接在单链表中查找，所以每次查找中点的**时间复杂度为O(NlogN)，空间复杂度O(logN）**

**代码：**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        //特判空树
        if (!head) return NULL;
        //求结点个数
        int n = 0 ;
        for (auto p = head ; p ; p = p->next) n ++;
        //特判1个结点
        if (n == 1 ) return new TreeNode(head->val);
        //找到中点前一个结点
        auto cur = head;
        for (int i = 0 ;i < n / 2 - 1 ; i++) cur = cur->next;
        //中点作为根节点
        auto root = new TreeNode(cur->next->val);
        //递归右边
        root->right = sortedListToBST(cur->next->next);
        //递归左边
        cur->next = NULL;
        root->left = sortedListToBST(head);

        return root;
    }
};
```

# 110.平衡二叉树

![image-20201112115952485](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112120001151.png)

![image-20201112120001151](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112100834638.png)

## 左子树右子树高度差绝对值不超过1

这题我们直接利用定义，左子树和右子树的高度差绝对值不超过1.深度优先搜索

**时间复杂度O(N)，空间复杂度O(logN)**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool res = true;
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return res;
    }

    int dfs(TreeNode* root){
        //空树，高度0
        if (!root) return 0;
        int lh, rh;
        //递归求左子树和右子树的高度
        lh = dfs(root->left);
        rh = dfs(root->right);
        //判断左右子树高度差
        if (abs(lh - rh) > 1) res = false;
        //返回树的高度
        return max(lh, rh) + 1;
    }
};
```

# 111. 二叉树的最小深度

![image-20201112121459911](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112130532486.png)

![image-20201112121504563](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112121459911.png)

![image-20201112122238129](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112121504563.png)

## 递归的看

本质就是深搜

![image-20201118225438924](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118225438924.png)

**时间复杂度O(N)**

**代码：**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        //空树
        if (!root) return 0;
        //叶节点
        if (!root->left && !root->right) return 1;
        //左右子树都不空
        if (root->left && root->right) return min(minDepth(root->left), minDepth(root->right)) + 1;
        //左子树不空
        if (root->left) return minDepth(root->left) + 1;
        //右子树不空
        if (root->right) return minDepth(root->right) + 1;
        return 0;
    }
};
```

# 112. 路径总和

![image-20201112130926792](https://gitee.com/xddadd/cloud-image/raw/master/image-20201112132725682.png)



## 深搜

从上到下搜索，每次sum-当前节点。

如果到达叶子节点且sum=0了，说明满足要求

**时间复杂度O(N)**

**代码:**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        sum -= root->val;
        if (!root->left && !root->right && !sum) return true;
        return root->left && hasPathSum(root->left, sum) || root->right && hasPathSum(root->right, sum);
    }
};
```

# 113. 路径总和 ||

![image-20201118225602229](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118225602229.png)

## 深度优先搜索

和112题类似，不过需要返回所有满足要求的路径

在深搜的过程中，我们用一个数组来记录当前路径上的路径和

**时间复杂度O(N^2^)，空间复杂度O(N)**

最坏情况是N个结点叶子结点个数是O(N)，

`ans.push_back(path);`这句话会把path复制一遍，path的长度是 O(n)的，最坏情况下会复制 O(n) 次，所以总时间复杂度最坏是 O(n^2^) 的。

**代码:**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if (root) dfs(root, sum);
        return res;
    }

    void dfs(TreeNode* root, int sum){
        path.push_back(root->val);
        sum -= root->val;
        //叶节点，切路径和满足
        if (!root->left && !root->right && sum == 0){
            res.push_back(path);
        }else {
            //递归左子树和右子树
            if (root->left) dfs(root->left, sum);
            if (root->right) dfs(root->right, sum);
        }
        //回溯恢复
        path.pop_back();
    }
};
```

# 114. 二叉树展开为链表

![image-20201118200350007](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118200350007.png)

## 找规律

- 对于每个节点root来说，若有左子树，那么从左子树向右遍历，直到最后一个节点
- 将左子树右边最后一个节点的右指针指向root的right域，root的right域指向左子树，并且left置空
- 循环上面的

![image-20201118200919996](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118200919996.png)

经过一次上面的步骤后，会变成

![image-20201118200936782](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118200936782.png)

root每次向右走，一直重复...

==时间复杂度O(N)，空间复杂度O(N)==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        while (root){
            //有左子树
            if (root->left){
                auto p = root->left;
                while (p->right) p = p->right;
                //改变指针指向
                p->right = root->right;
                root->right = root->left;
                root->left = NULL;
            }
            root = root->right;
        }

        
    }
};
```

# 116. 填充每个节点的下一个右侧节点指针

![image-20201118202612084](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118202612084.png)

## 二叉树的层序遍历

第一个想法肯定是层序遍历，然后因为该数是完美二叉树，所以如果可以将每层的结点连成链表形式。

如果该层已经连成了单链表，那么我们如果直到该层的做左边的结点，那么可以从左往右的遍历下层的结点，从而达到层序遍历的效果。

1.每次用当前层的结点将下面一层变成一个单链表。

2.对于该层的每个结点，左儿子指向自己的右儿子，还得将自己的右儿子指向下一个结点的左儿子。

3.用当前层更新完下一层的结点，跳到下一层的最左边。

![image-20201118211752639](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118211752639.png)

==时间复杂度O(N), 空间复杂度O(1)==

## AC代码

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (!root)  return NULL;
        auto cur = root;
        //下层有结点
        while (cur->left){
            //用当前层去更新下层的next
            for (auto p = cur ; p ; p = p->next){
                p->left->next = p->right;
                if (p->next) p->right->next = p->next->left;
            }
            //跳到下层最左边
            cur = cur->left;
        }

        return root;
    }
};
```

# 117. 填充每个节点的下一个右侧节点指针 ||

![image-20201118204202815](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118204202815.png)

## 二叉树的层序遍历

第一次看，我们想到的思路肯定都是层序遍历，但是题目要求必须空间复杂度O(1)，所以不能层序遍历。我们还是对上面一题的做法进行改进。

1.还是用每层最左边的节点去更新下一层的next

2.把下一层看成一个单链表，遍历当前层，我们用一个虚拟头节点将下一层的节点链接起来

3.每次更新完下一层的next后，我们再跳到下一层的最左边的节点。

==时间复杂度O(N)，空间复杂度O(1)==

## AC代码

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (!root) return root;
        auto cur = root;
        while (cur){
            //将下一层看成单链表，连起来
            auto head = new Node(-1), tail = head;
            for (auto p = cur ; p ; p = p->next){
                if (p->left) tail = tail->next = p->left;
                if (p->right) tail = tail->next = p->right;
            }
            //跳到下一层最左边
            cur = head->next;
        }

        return root;
    }
};
```

# 124. 二叉树中的最大路径和

![image-20201118205832086](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118205832086.png)

## 枚举递归

对于该题，我们要枚举，以每个节点为路径的最高点的路径和最大是多少。

如果确定了某个点为最高点，那么以该节点为最高点的路径和最大应该是该节点加上以左边为最高点的路径和最大，再加上以右边为最高点的路径和最大。

有点类似与DP

![image-20201118220908800](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118220908800.png)

==时间复杂度O(N)，空间复杂度O(1)

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }

    int dfs(TreeNode* root){
        //空节点
        if (!root) return 0;
        //递归求左节点和右节点路径最大和
        int leftMax = max(0, dfs(root->left));
        int rightMax = max(0, dfs(root->right));
        //更新枚举当前点位最高点的答案
        res = max(res, root->val + leftMax + rightMax);
        //返回当前点为最高点的值
        return root->val + max(leftMax, rightMax);
    }

};
```

# 129. 求根到叶子节点数之和

![image-20201118221003223](https://gitee.com/xddadd/cloud-image/raw/master/image-20201118221003223.png)

## 深搜

如果用一个数字来维护从根节点开始到当前节点数字的话：`num = num * 10 + v`，所以我们采用深搜，当到达叶子节点时候，即将答案加上路径的值。

==时间复杂度O(N)，空间复杂度O(1)==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int res = 0;
    int sumNumbers(TreeNode* root) {
        if (root) dfs(root, 0);
        return res;
    }

    void dfs(TreeNode* root, int num){
        
        num = num * 10 + root->val;
        //叶节点
        if (!root->left && !root->right) res += num;
        //递归左子树和右子树
        if (root->left) dfs(root->left, num);
        if (root->right) dfs(root->right, num);
    }
};
```

# 144. 二叉树的前序遍历

![image-20201119144658844](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119144658844.png)

![image-20201119144205952](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119144212789.png)

## 二叉树的前序遍历

二叉树的前序遍历：根左右

以下会给出递归和迭代的做法

==时间复杂度O(N)，空间复杂度O(H)，H为树的高度==

## 递归代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> preorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* root){
        if (!root) return;
        //根
        res.push_back(root->val);
        //左子树和右子树
        dfs(root->left);
        dfs(root->right);
    }

};
```

## 迭代代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        //前序遍历
        while (root || stk.size()){
            while (root){
                //根
                res.push_back(root->val);
                //左
                stk.push(root);
                root = root->left;
            }
            //向右
            root = stk.top()->right;
            stk.pop();
        }
        //返回答案
        return res;
    }

};
```

# 145. 二叉树的后序遍历

![image-20201119162749323](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119162749323.png)

## 二叉树的后序遍历

二叉树的后序遍历是：左右根。

前序遍历和中序遍历分别是根左右和左根右，而后序遍历是最后才遍历根节点，所以我们的迭代方法只能换个思路。由于后序遍历是左右根，我们可以用之前的迭代的方法做到根右左，最后反转一下即是左右根。

==时间复杂度O(N)，空间复杂度O(H)==

## 递归代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* root){
        if (!root) return ;
        //先递归左子树和右子树
        dfs(root->left);
        dfs(root->right);
        //根节点
        res.push_back(root->val);
    }
};
```

## 迭代代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root || stk.size()){
            while (root){
                //根
                res.push_back(root->val);
                stk.push(root);
                //右
                root = root->right;
            }
            //左
            root = stk.top()->left;
            stk.pop();
        }
        //反转
        reverse(res.begin() , res.end());

        return res;
    }
};
```

# 173. 二叉搜索树迭代器

![image-20201119165424948](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119165424948.png)

## 二叉树的中序遍历

由二叉搜索树中序遍历有序性。且中序遍历的顺序是：左根右。所以该题主要是对二叉树中序遍历代码的拆分。

1.初始化

- 初始化，我们先将根节点的左子树遍历，并且压入栈

2.next

- 因为是中序遍历，所以当前栈顶就是最小的元素
- 弹出后再将该节点向右，并且将左子树都遍历，压入栈

3.hasNext

- 栈中如果有节点，说明还没有遍历完
- 栈中如果没有节点，说明遍历完了

## AC代码

**注意：下面的代码是二叉树中序遍历迭代代码的拆分**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
public:
    stack<TreeNode*> stk;
    BSTIterator(TreeNode* root) {
        //根节点的左子树入栈
        while (root){
            stk.push(root);
            root = root->left;
        }
    }
    
    /** @return the next smallest number */
    int next() {
        //栈顶为最小元素
        auto root = stk.top();
        int v = root->val;
        stk.pop();
        //将栈顶的元素的转向右边
        root = root->right;
        //左子树全入栈
        while (root){
            stk.push(root);
            root = root->left;
        }
        return v;
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        return stk.size();
    }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj->next();
 * bool param_2 = obj->hasNext();
 */
```

# 199. 二叉树的右视图

![image-20201119211301527](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119211301527.png)

## 广度优先搜索

该题的题意是求出每层最右边的节点。利用二叉树的层序遍历，记录每层的最后一个节点。

==时间复杂度O(N)，空间复杂度O(L)，L为每层的最大值==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> q;
        if (root) q.push(root);
        while (q.size()){
            int len = q.size();
            for (int i = 0 ; i < len ; i ++){
                auto t = q.front();
                //记录每层的最后一个节点
                if (i == len - 1) res.push_back(t->val);
                q.pop();
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
        }

        return res;
    }
};
```

# 222. 完全二叉树的节点个数

![image-20201119211820415](https://gitee.com/xddadd/cloud-image/raw/master/image-20201119211820415.png)

## 思路

提到完全二叉树，不得不提满二叉树，满二叉树是每层节点的个数都是最多的，即类似一个等腰三角形。

![image-20201120185320416](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120185320416.png)

而完全二叉树是满二叉树最后一层从右往左缺几个节点，因此可以说满二叉树是特殊的完全二叉树。

- 对于一个满二叉树而言，如果我们直到层数（深度），那么一定能确定该树的节点个数

- 对于一个不是满二叉树而言，它的子树可能是满二叉树，利用这个性质，我们递归的来求节点个数

时间复杂度$O((logN)^2)$

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        //空树
        if (!root) return 0;
        //看当前树的是否是满二叉树
        auto pl = root->left, pr = root->right;
        int l = 1 , r = 1;
        while (pl) l ++ , pl = pl->left;
        while (pr) r ++ , pr = pr->right;
        //满二叉树
        if (l == r) return (1 << l) - 1;
        //非满二叉树
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

# 226. 翻转二叉树

![image-20201120192636085](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120192636085.png)

## 中轴对称

![image-20201120192729262](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120192729262.png)

该题的意思是演中间轴翻转，即将左子树和右子树交换一下即可。递归来求解

==时间复杂度O(N)==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //空
        if (!root) return NULL;
        //交换左右子树
        swap(root->left, root->right);
        //递归翻转左子树和右子树
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

# 230. 二叉搜索数种第k小的元素

![image-20201120192954341](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120192954341.png)

## 二叉搜索树中序遍历有序

利用二叉搜索树中序遍历有序的性质，我们中序遍历，当遍历到第k个节点时候，即是第k小的元素。

==时间复杂度O(N)==

## 递归代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res;
    int kthSmallest(TreeNode* root, int k) {
        dfs(root, k);
        return res;
    }

    bool dfs(TreeNode* root, int& k){
        //空树
        if (!root) return false;
        //递归左子树
        if (dfs(root->left, k)) return true;
        //判断当前节点是否是第k小
        k --;
        if (k == 0){ 
            res = root->val;
            return true;
        }
        //递归右子树
        dfs(root->right, k);
        return false;
    }
};
```

## 迭代代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> stk;
        //中序遍历
        while (root || stk.size()){
            while (root){
                stk.push(root);
                root = root->left;
            }

            if (stk.size()){
                auto t = stk.top();
                stk.pop();
                //判断是否遍历到了第k个点
                k --;
                if (k == 0) return t->val;
                root = t->right;
            }
        }

        return -1;
    }
};
```

# 236 & 235. 二叉树的最近公共祖先

![image-20201120194351934](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120194351934.png)

![image-20201120194358363](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120194358363.png)

## 二叉树最近公共祖先

对于任意一个点，他自己，他的父亲，父亲的父亲.....都是该点的祖先。

对于两个点来说，两个点的父亲肯定有相交的祖先，找到离两个点最近的公共的祖先，就是二叉树的最近公共祖先，也称为最低公共祖先

![image-20201116215739073](https://gitee.com/xddadd/cloud-image/raw/master/image-20201116215739073.png)

例如对于7和6来说，5是他们最近的公共祖先

对于该问题有两种情况

1.对于某个点来说，两个点分别在该节点的左子树和右子树，则该点就是两点的最近公共祖先![image-20201116215933165](https://gitee.com/xddadd/cloud-image/raw/master/image-20201116215933165.png)

2.对于某个点来说，该点就是两点之一，另外一个点在该点的左子树或者右子树，所以该点就是两点的最近公共祖先

![image-20201116220238247](https://gitee.com/xddadd/cloud-image/raw/master/image-20201116220238247.png)

**思路:**

我们根据定义来搜索即可。

==时间复杂度O(N)==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //空树
        if (!root) return NULL;
        //递归到q/p了
        if (root == p || root == q) return root;
        //枚举q和p分别在左子树和右子树
        auto l = lowestCommonAncestor(root->left, p , q);
        auto r = lowestCommonAncestor(root->right, p , q);
        //当前点是最近公共祖先
        if (l && r) return root;
        //公共祖先在左/右子树
        if (l) return l;
        return r;
    }
};
```

# 257. 二叉树的所有路径

![image-20201120200918598](https://gitee.com/xddadd/cloud-image/raw/master/image-20201120200918598.png)



## dfs深搜

经典dfs。

==时间复杂度O(N^2^)，每个节点遍历N遍，但是我们还要拷贝答案==

## AC代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<string> res;
    vector<int> path;
    vector<string> binaryTreePaths(TreeNode* root) {
        if (root) dfs(root);
        return res;
    }

    void dfs(TreeNode* root){
        path.push_back(root->val);
        //叶节点
        if (!root->left && !root->right){
            string t = to_string(path[0]);
            for (int i = 1 ; i < path.size() ; i ++){
                t += "->" + to_string(path[i]);
            }
            res.push_back(t);
        } 
        else{
            //非叶节点
            if (root->left) dfs(root->left);
            if (root->right) dfs(root->right);
        }
        //回溯
        path.pop_back();
    }
};
```

