# 哈希表

## leetcode哈希表

# 387.字符串中的第一个唯一字符

![image-20201224221857941](https://gitee.com/xddadd/cloud-image/raw/master/image-20201224221857941.png)

## 哈希表

统计每个字符出现次数，再从头遍历，输出第一个只出现依次的字符

时间复杂度O(N)，空间复杂度O(K)，K为26个字母的大小

## AC代码

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        vector<int> hash(26, 0);
        //插入哈希表
        for (auto c : s) hash[c - 'a'] ++;
        //遍历
        for (int i = 0 ; i < s.size() ; i ++){
            if (hash[s[i] - 'a'] == 1) return i;
        }
        return -1;
    }
};
```

# 205.同构字符串

![image-20210525142146306](https://gitee.com/xddadd/cloud-image/raw/master/image-20210525142146306.png)



## 双哈希映射

> 为什么要用两个哈希表呢?
>
> 因为在s中'a'映射t的'b'，而t的'b'可以映射s的'c'

1. 首先判断字符串长度是否相等
2. 同时遍历两个字符串
   - s[i]存在ms中，并且s[i]对应的t[i]不相等，返回false
   - t[i]存在mt中，并且t[i]对应的s[i]不相等，返回false
   - s[i]和t[i]都不存在ms和mt中，插入哈希表
3. 遍历完，说明没问题，返回true

时间复杂度 $O(N)$，空间复杂度$O(N)$

## AC代码

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int n = s.size(), m = t.size();
        if (n != m) return false;
        if (!n) return true;
        unordered_map<char,char> ms, mt;

        for (int i = 0 ; i < n ; i ++) {
            if (ms.count(s[i]) && ms[s[i]] != t[i])
                return false;
            if (mt.count(t[i]) && mt[t[i]] != s[i])
                return false;
            if (!ms.count(s[i]) && !mt.count(t[i])){
                ms[s[i]] = t[i];
                mt[t[i]] = s[i];
            }
        }
        return true;
    }
};
```

# 290.单词规律

![image-20210604211459321](https://gitee.com/xddadd/cloud-image/raw/master/image-20210604211459321.png)

## 双哈希

我们用两个哈希表。一个维护pattern的字母和单词的映射，另外一个维护单词和pattern的字母的映射。

模拟匹配即可。

时间复杂度$O(N)$，空间复杂度$O(N)$

## AC代码

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        int n = s.size(), m = pattern.size();
        for (int i = 0 ; i < n ; i ++) {
            if (s[i] == ' ') continue;
            string t;int j = i;
            while (j < n && s[j] != ' ') t += s[j ++];
            i = j;
            words.push_back(t);
        }
        n = words.size();
        if (n != m) return false;
        unordered_map<char, string> ps;
        unordered_map<string, char> sp;
        for (int i = 0 ; i < m ; i ++) {
            char c = pattern[i];
            if (ps.count(c) && ps[c] != words[i]) 
                return false;
            ps[c] = words[i];
            if (sp.count(words[i]) && sp[words[i]] != c)
                return false;
            sp[words[i]] = c;
        }
        return true;
    }
};
```

# 380.常数时间插入、删除和获取随机元素

![image-20210610140343470](https://gitee.com/xddadd/cloud-image/raw/master/image-20210610140343470.png)

## 哈希表+数组

设计数据结构，支持三个操作都要$O(1)$：

1. 插入v到集合
2. 从集合删除v
3. 返回集合中的随机一个元素，等概率

> 因为要随机返回一个元素，所以用数组存储，配合哈希表插入和删除操作都能到$O(1)$
>
> 删除$O(1)$只需要将元素移动到数组的末尾删除即可。

## AC代码

```cpp
class RandomizedSet {
public:
    unordered_map<int,int> h;
    vector<int> nums;
    /** Initialize your data structure here. */
    RandomizedSet() {

    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        if (!h.count(val)){
            h[val] = nums.size();
            nums.push_back(val);
            return true;
        }
        return false;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        if (h.count(val)) {
            int i = h[val];
            swap(h[val], h[nums[nums.size() - 1]]);
            swap(nums[i], nums[nums.size() - 1]);
            h.erase(val);
            nums.pop_back();
            return true;
        }
        return false;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

# 381.O(1) 时间插入、删除和获取随机元素 - 允许重复

![image-20210610161756622](https://gitee.com/xddadd/cloud-image/raw/master/image-20210610161756622.png)

## 哈希表+数组

> 插入删除操作用哈希表
>
> 随机访问用数组

跟上题类似，不过有重复元素，所以我们需要嵌套哈希表，存储某个元素的在数组中多个出现次数

删除操作也是类似，将末尾元素和x交换再删除

## AC代码

```cpp
class RandomizedCollection {
public:
    unordered_map<int, unordered_set<int>> h; //在数组中出现的位置
    vector<int> nums;

    /** Initialize your data structure here. */
    RandomizedCollection() {

    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    bool insert(int val) {
        bool flag = h[val].empty();
        h[val].insert(nums.size());
        nums.push_back(val);
        return flag;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    bool remove(int x) {
        if (h[x].size()) {
        int px = *h[x].begin(), py = nums.size() - 1;
            int y = nums.back();
            swap(nums[px], nums[py]);
            h[x].erase(px), h[x].insert(py);
            h[y].erase(py), h[y].insert(px);
            nums.pop_back();
            h[x].erase(py);
            return true;
        }
        return false;
    }
    
    /** Get a random element from the collection. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection* obj = new RandomizedCollection();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

# 383.赎金信

![image-20210610163115345](https://gitee.com/xddadd/cloud-image/raw/master/image-20210610163115345.png)

## 哈希表

用哈希表模拟统计一遍

## AC代码

```cpp
class Solution {
public:
    bool canConstruct(string r, string m) {
        unordered_map<char,int> h;
        for (auto c : r) h[c] ++;
        for (auto c : m) h[c] --;
        for(auto& [s, c] : h){
            if (c > 0)
                return false;
        }
        return true;
        
    }
};
```

