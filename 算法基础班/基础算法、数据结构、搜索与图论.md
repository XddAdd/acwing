# 第一章 基础算法

## 快速排序

闭区间

```c++
void quick_sort(int nums[],int l,int r){
    if(l>=r) return;
    int x = nums[l+r>>1];
    int i =l - 1,j = r + 1;
    while(i<j){
        do i++;while(nums[i]<x);
        do j--;while(nums[j]>x);
        if(i<j) swap(nums[i],nums[j]);
    }
    quick_sort(nums,l,j);
    quick_sort(nums,j+1,r);
}
```

## 归并排序

闭区间

```c++
void merge_sort(int nums[],int l,int r){
    //递归边境
    if(l>=r) return;
    //先递归的对左右两个数组进行排序
    int mid=l+r>>1;
    merge_sort(nums,l,mid);
    merge_sort(nums,mid+1,r);
    //将已经排序好的两个数组归并
    int k = 0,i = l,j = mid+1;
    while(i<=mid&&j<=r){
        if(nums[i] <= nums[j]) temp[k++]=nums[i++];
        else temp[k++]=nums[j++];
    }
    while(i <= mid) temp[k++] = nums[i++];
    while(j <= r) temp[k++] = nums[j++];
    
    //将temp的数组中的元素copy回nums数组
    for(int i = l,j = 0;i <= r;	i++,j++) nums[i]=temp[j];
    
    
}
```

## 二分查找

两个模板:

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}

```

```c++
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

求某个数的2次方根

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

**注意：**要保证l < r,如果l = 0 , r = x的话，可能x是负数，前面要加一个判断，保证l < r.

## 高精度加法

1<=a和b的长度<=10000，且非负数

```c++
vector<int> add(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;
    for(int i = 0;i < a.size() || i<b.size();i++){
        if(i<a.size()) t+=a[i];
        if(i<b.size()) t+=b[i];
        c.push_back(t%10);
        t/=10;      
    }
    
    //对最后一个进位处理
    if(t) c.push_back(t);
    return c;
}
```

 

## 高精度减法

1<=a和b的长度<=10000，且非负数，a>=b

```c++
vector<int> sub(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;
    for(int i=0;i<a.size();i++){
        t=a[i]-t;
        if(i<b.size()) t-=b[i];
        c.push_back((t+10)%10);
        if(t<0) t=1;
        else t=0;
    }
    
    //去前导0
    while(c.size()>1&&c.back()==0) c.pop_back();
    return c;
}
```

上面判断a,b的大小的函数，是否a>=b

```c++
bool cmp(vector<int> &a,vector<int> &b){
	if(a.size()!=b.size()) return a.size()>b.size();
    for( int i= a.size()-1 ;i--)
        if(a[i]!=b[i]) return a[i]>b[i];
    return true;//两个数相等，返回true
}
```



## 高精度乘法

1<=a的长度<=10000，0<=b<=1000

```
vector<int> mul(vector<int> &a,int b){
	vector<int> c;
	int t=0;
	for(int i=0;i<a.size() || t ;i++){
		if(i<a.size())  t=a[i]*b+t;
		c.push_back(t%10);
		t/=10;
	}
	//去除前导0
	while(c.size()>1 && c.back()==0) c.pop_back();
	
	return c;
}
```

## 高精度除法

1<=a的长度<=10000，0<b<=1000,都是正数

```c++
vector<int> div(vector<int> &a, int b ,int &r){
    vector<int> c;
    
    for (int i=a.size()-1;i>=0;i--){
        r=a[i]+10*r;
        c.push_back(r/b);
        r%=b;
    }
    
    reverse(c.begin(),c.end());//反转
    //去除前导0
    while(c.size()>1 && c.back()==0) c.pop_back();
    
    return c;
 

```



## 前缀和

数组a1,a2,a3,a4......an

其前缀和数组b1,b2,b3,b4.....bn

其中bk=a1+a2+.....+ak，则b[k]=b[k-1]+a[k];

注意：数组0下标不存储，存0即可

可以边读a数组的输入，边计算b数组

```
for(int i = 1;i <= n; i++){
	cin>>a[i];
	b[i]=b[i-1]+a[i];
}
```

## 子矩阵的和（二维前缀和）

二维矩阵a的二维前缀和矩阵是s

则有:

```
s[i][j]=  s[i-1][j]  +  s[i][j-1]  -  s[i-1][j-1]  +  a[i][j];
```

![image-20200923191225622](https://gitee.com/xddadd/cloud-image/raw/master/image-20200923191225622.png)

如果要计算二维的矩阵和(x1,y1)到(x2,y2)

则有：

```c++
ans = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1];
```

![image-20200923191005264](https://gitee.com/xddadd/cloud-image/raw/master/image-20200923191005264.png)

## 双指针

类似模板

```c++
for(int i = 0,j = 0;i < n;i ++ ){
	while(i < j && check(i,j)) j++;
	//其他的逻辑....
}
```

例如：

#### 799. 最长连续不重复子序列

给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

输入格式

第一行包含整数n。

第二行包含n个整数（均在0~100000范围内），表示整数序列。

输出格式

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

数据范围

1≤n≤100000

```c++
#include <iostream>
using namespace std;

const int N = 1e6+10;

int a[N],h[N];
int n;


int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    
    int ans = 0;
    for(int i=0,j=0;i<n;i++){
        h[a[i]]++;
        while(h[a[i]]>1){
            h[a[j]]--;
            j++;
        }
        ans = max(ans ,i-j+1);
    }
    cout<<ans;
    
    return 0;
}
```

### Unique()函数的实现

unique函数是将有序数组中所有重复的元素去重，将不重复的元素防在数组的前面

返回值：返回值是最后一个不重复元素的下个元素的迭代器

```c++
vector<int>::iterator unique(vector<int> &a){
    int j = 0;
    for (int i =0 ; i < a.size(); i++){
        if( !i || a[i - 1] != a[i] )
            a[j++] = a[i] ;
    }
    return  a.begin() + j;
}
```

## 位运算

n的二进制的第k为是0还是1？k从右到左0-n-1

n右移k未，在与1，得到第k为是几

```c++
n >> k & 1;
```

lowbit(x);

返回x的最后一位1是多少，例如x = 1010,lowbit(x) = 10;

```c++
int lowbit(int x){
	return x & -x;
}
```



## 离散化

离散化是将无限长的数轴上的有值元素映射到一个数组中(即将稀疏的数组进行聚合)

给定无限长的数轴，数轴上的每个数都为0，n次插入操作，给数轴上的x加上c，

m次查询，每次数轴上[1,r]区间的和

acwing上的802. 区间和

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 300010;
typedef pair<int, int> PAIR;

int a[N], s[N];//a数组存储离散化后，数轴+c的值，s数组为a数组的前缀和
vector<int> alls;//存储数轴上出现的x，包括l,r
vector<PAIR> add, query;//add存储添加到数轴上的记录，query存储l,r区间
int m, n;



//对数组去重，将所有的不重复元素放到数组的前面，返回后面的重复部分的头迭代器
vector<int>::iterator unique(vector<int> &a){
    int j = 0;
    for(int i = 0; i < a.size(); i++ ){
        if( i == 0 || a[i] != a[j])
            a[j++] = a[i];
    }
    
    return a.begin() + j;
}

int getIndex(vector<int> &a , int x){
    int l = 0 , r = a.size() - 1;
    while(l < r){
        int mid = l + r >> 1;
        if(a[mid] >= x) r = mid;
        else l = mid +1;
    }
    return l + 1;
    
}

int main(){
    cin >> n >> m;
    //读入n次插入操作
    for (int i =0; i < n; i++){
        int x, c;
        cin >> x >> c;
        alls.push_back(x);
        add.push_back({x, c});
    }
    //读入m次的查询区间
    for (int i = 0; i < m; i++){
        int l, r;
        cin >> l >> r;
        alls.push_back(l);
        alls.push_back(r);
        query.push_back({l, r});
    }
    
    //对alls数组进行排序并且去重
    sort(alls.begin() , alls.end());
    alls.erase(unique(alls), alls.end());
    
    //离散化到a数组
    for (auto item : add){
        int x = item.first, c = item.second;
        int index = getIndex(alls,x);
        a[index] += c;
    }
    
    //求a数组的前缀和s
    for(int i = 1 ;i <= alls.size() ;i++)  s[i] = s[i - 1] + a[i];
    
    //处理m次查询的区间输出
    for (auto item : query){
        int l , r;
        l = getIndex(alls,item.first);
        r = getIndex(alls,item.second);
        cout << s[r] - s[l-1] << endl ;
    }
    return 0;
}
```



## 区间合并

给定n个[l,r]的闭区间，求最终合并后的区间的个数

acwing上的803. 区间合并

**步骤：**

1. 按照区间的左端点从小到大排序
2. 用start,end代表当前区间，扫描每个区间，根据不同情况来更新start和end，初始化count=1

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int>  PAIR;



int n;
vector<PAIR> a; 

bool cmp(PAIR a, PAIR b){
    return a.first<=b.first;
}
int main(){
    cin>>n;
    //读入n个区间
    for(int i =0 ; i < n; i++){
        int l,r;
        cin >> l >> r ;
        a.push_back({l,r});
    }
    //所有区间的左端点进行排序
    sort(a.begin(),a.end(),cmp);
    
    //扫描排序后的所有区间，并且统计区间的个数
    int start , end;
    int count ;
    for(int i = 0; i < n; i++){
        if( i == 0){//第一个区间，初始化start,end count
            start = a[i].first;
            end = a[i].second;
            count = 1;
        }else{//非第一个区间
            if( end < a[i].first){
                //该区间和不属于[start,end]
                start = a[i].first;
                end = a[i].second;
                count++;
            }else if( end < a[i].second ){
                //该区间左端点在[start,end]内部，但是右端点不在该区间内
                end = a[i].second;
            }
            //最后一个情况是该区间在[start,end]内部，什么都不需要更新
            
        }
    }
    
    cout << count << endl;
    
    return 0;
}
```

# 第二章 数据结构

## 单链表

e[i]表示地址为i的value

ne[i]表示地址为i的next

head表示的是头指针

idx表示当前数组可以用的下标编号，递增的

**注意**：数组的大小N需要提前进行定义

```c++
int e[N],ne[N];
int head,idx;
```

**单链表的初始化**

```c++
void init(){
    head = -1;
    idx = 0;
}
```

**链表头插入一个结点**

```c++
void add_to_head(int value){
    e[idx] = value;
    ne[idx] = head;
    head =  idx++;
}
```

**在地址为k的后面添加一个新结点**

```c++
void add(int k ,int value){
    e[idx] = value;
    ne[idx] = ne[k];
    ne[k] = idx ++;
}
```

注意：该操作是在地址(数组的下标)为k的后面的下标添加一个新结点，而不是单链表的第k个数后面添加，该操作为**O(1)**，如果需要在单链表第k个结点后面添加一个结点的话需要遍历单链表，找到第k个结点的地址后再添加一个新结点，这样操作的为**O(N)**.

**移除地址为k的结点后面的结点**

```c++
void remove(int k ){
    ne[k] = ne[ne[k]];
}
```

注意：该操作也是对地址为k的结点进行操作的，而不是单链表的第k个数。时间复杂度同上。

## 双链表

e[i]表示地址为i的value

l[i]表示地址为i的结点的前面的结点的地址

r[i]表示地址为i的结点的后面的结点的地址

0, 1分别是头指针和尾指针

idx表示当前数组可以用的下标编号，递增的

**双链表的初始化**

```c++
void init(){
    //0 , 1 分别代表的是链表的头指针和尾指针
    //初始化头指针右边是尾指针，尾指针左边是头指针
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}
```

注意：这里并没有定义头指针和尾指针，头指针是0，尾指针是1，初始化的时候是头指针右边是尾指针，尾指针左边是头指针。

**链表头插入一个结点**

```c++
void add_to_head( int value){
    e[idx] = value;
    l[idx] = 0;//新节点的左节点为头结点
    r[idx] = r[0];//新结点的右节点为头节点的右节点
    l[r[0]] = idx;
    r[0] = idx++;
}
```

**链表尾插入一个结点**

```c++
void add_to_tail( int value){
    e[idx] = value;
    r[idx] = 1;//新节点的右节点为尾节点
    l[idx] = l[1];//新结点的左节点为尾节点的左节点
    r[l[1]] = idx;
    l[1] = idx++ ;
}
```

**在地址为k的后面添加一个新结点**

```c++
void add (int k , int value){
    e[idx] = value;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx++;
}
```

**移除地址为k的结点**

```c++
void remove (int k ){
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```

注意：这里并不是真正意义上的删除，而是将该该节点的前后节点互相进行指向。

acwing.827.双链表

```c++
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int n ;
int l[N],r[N], e[N], idx;


void init(){
   r[0] = 1;
   l[1] = 0;
   idx = 2;
}

void add_to_head(int x){
    e[idx] = x;
    r[idx] = r[0];
    l[idx] = 0;
    l[r[0]] = idx;
    r[0] = idx ++;
}

void add_to_tail(int x){
    e[idx] = x;
    l[idx] = l[1];
    r[idx] = 1;
    r[l[1]] = idx;
    l[1] = idx ++;
}

void add_to_right(int k ,int x){
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx;
    idx ++;
}

void add_to_left(int k ,int x){
    e[idx] = x;
    r[idx] = k;
    l[idx] = l[k];
    r[l[k]] = idx;
    l[k] = idx;
    idx ++;
}

void del(int k){
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}

int main(){
    cin >> n;
    init();
    
    while ( n -- ){
        char op[3];
        int k , x;
        cin >> op;
        if (*op == 'L'){
            cin >> x;
            add_to_head(x);
        }else if (*op == 'R'){
            cin >> x;
            add_to_tail(x);
        }else if (op[1] == 'L'){
            cin >> k >> x;
            add_to_left(k+1,x);
        }else if (op[1] == 'R'){
            cin >> k >> x;
            add_to_right(k+1,x);
        }else{
            cin >> k;
            del(k+1);
        }
    }
    
    //输出双链表
    for (int p = r[0] ; p != 1 ; p=r[p]){
        cout << e[p] << " ";
    }
    return 0;
}
```



## 栈

用数组模拟栈，只需要一个数组和一个top的指针

```c++
int stk[N] , tt;
```

stk是栈，而tt是当前栈顶位置。

**初始化**

```c++
tt = 0;
```

注意 ：初始化tt为0，则该栈从下标为1开始存储，该初始化和下面的判断栈为空有关

**判断栈是否空**

```c++
if ( tt > 0) not empty;
else empty;
```

注意：由于上面的栈从1开始存储，所以判断栈是否空是判断>0,如果栈从0开始存储，则需要更改判断的条件

**插入**

```c++
stk[ ++tt ] = x;
```

**弹出**

```c++
tt --;
```

****

**取栈顶元素**

```c++
int x = stk[ tt ]
```



**注意**：上面的插入、弹出、取栈顶元素都需要判断一下栈是否为空或者是栈是否满，否则容易报错。

## 队列

在队尾插入元素，在对头弹出元素

```c++
int q[N], hh = 0, tt = -1;
```

q是队列，hh表示对头指针，tt表示队尾指针

并且队列的元素是[ hh , tt ]的闭区间

**初始化**

```c++
hh = 0  , tt = -1;
```

初始化对头指向0，队尾指向-1

**判断队列是否为空**

```c++
if ( hh <=  tt ) not empty;
else empty;
```

**队尾插入元素**

```c++
q[ ++ tt ] = x;
```

**取出对头元素**

```c++
q[ hh ];
```

**弹出**

```c++
hh ++ ;
```



**注意**：上面的插入、弹出、取对头元素都需要判断一下队列是否为空或者是该数组是否满了，否则容易报错。

## 单调栈

单调栈是栈是一种单调性，栈内元素是依次递增或者是递减的。(单调栈用的地方少)

作用：给定一个序列，求序列中的每个数左边(右边)离该数最近切比该数大(小)的数

acwing 830.单调栈

**题意：**给定一个序列，输出该序列中每个数左边离该数最近切比该数最小的数，如果左边的数都比该数大，则输出-1

**解题思路**：每次处理第i个数，如果该数比栈顶元素小，则从栈里面删除，直到空或者栈顶比该数小。删除完后，判断栈是否为空，如果为空，则说话栈里面的数都比该数大，则该数左边没有比该数小的数，如果栈不为空，则说明栈顶元素比该数小，则直接输出栈顶元素即可。最后将该数也并入到栈中。

```c++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;

int stk[N], tt;

int main(){
    int n, x;
    cin >> n ;
    for (int i = 0; i < n; i++){
        cin >> x;
        while( tt && stk[tt] >= x ) tt--;
        if( tt ) cout << stk[tt] << " ";
        else cout << "-1 ";
        stk[ ++tt ] = x;
    }
    return 0;
}
```

注意：栈永远是单调的，根据题意可能是递增的或者是递减的。

## 单调队列

单调队列是队列是一种单调性，队列内元素是依次递增或者是递减的。(单调队列同上单调栈一样用的地方少)

作用：给定一系列的数，每次从左到右（或者从右到左）k个数的最大值(或者最小值)

acwing 154.滑动窗口

给定一个大小为n≤106n≤106的数组。

有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。

您只能在窗口中看到k个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为[1 3 -1 -3 5 3 6 7]，k为3。

| 窗口位置            | 最小值 | 最大值 |
| :------------------ | :----- | :----- |
| [1 3 -1] -3 5 3 6 7 | -1     | 3      |
| 1 [3 -1 -3] 5 3 6 7 | -3     | 3      |
| 1 3 [-1 -3 5] 3 6 7 | -3     | 5      |
| 1 3 -1 [-3 5 3] 6 7 | -3     | 5      |
| 1 3 -1 -3 [5 3 6] 7 | 3      | 6      |
| 1 3 -1 -3 5 [3 6 7] | 3      | 7      |

您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**输入格式**

输入包含两行。

第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。

第二行有n个整数，代表数组的具体数值。

同行数据之间用空格隔开。

**输出格式**

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

**输入样例：**

```
8 3
1 3 -1 -3 5 3 6 7
```

**输出样例：**

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

代码：

```c++
#include <iostream>
using namespace std;


const int N = 1e6 + 10;
int a[N], q[N], hh, tt = -1;

int main(){
    int n , k;
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
    
    //从左到右扫描，输出滑动窗口k的最小值
    for (int i = 0; i < n; i++) {
        //判断对头是否已经滑出窗口
        if( hh <= tt && i-k+1 > q[hh] ) hh++;
        while( hh <= tt && a[q[tt]] >= a[i]) tt--;
        q[ ++tt ]  = i;
        
        if( i >= k-1 ) cout << a[q[hh]] << " ";
    }
    printf("\n");
    //从左到右扫描，输出滑动窗口k的最大值
    for (int i = 0; i < n; i++) {
        if( hh <= tt && i-k+1 > q[hh] ) hh++;
        while( hh <= tt && a[q[tt]] <= a[i]) tt--;
        q[ ++tt ]  = i;
        
        if( i >= k-1 ) cout << a[q[hh]] << " ";
    }
}
```

**注意：**该题的单调队列并不是严格意义上的队列，而是维护一段单调性的序列，在保证最大值或者最小值在对头，每次插入元素，要保证元素插入到确定的位置，因为维护的是最大值(或者最小值)，所以元素插入到应该插入的位置后，后面所有元素都不需要了(因为区间是闭区间，包括自己)。

下面扫描最大值的代码和上面类似，只不过是把判断条件改成了`<=`,因为下面是求最大值，要保证从队头元素到队尾元素是递降的。

## KMP算法

KMP算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，是给定一个串(一般是字符串)和一个模式串pattern，求模式串在字符串中第一次出现的位置，返回下标，如果没找到的话，返回异常等...时间复杂度为**O(N+M)**,其中N是主字符串的长度，M是模式串的长度。

**一般存主串和模式串都是下标为1开始存。**

acwing.831.KMP字符串

给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串P在模式串S中多次作为子串出现。

求出模板串P在模式串S中所有出现的位置的起始下标。

**输入格式**

第一行输入整数N，表示字符串P的长度。

第二行输入字符串P。

第三行输入整数M，表示字符串S的长度。

第四行输入字符串S。

**输出格式**

共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。

**数据范围**

1≤N≤1051≤N≤105
1≤M≤1061≤M≤106

**输入样例：**

```
3
aba
5
ababa
```

**输出样例：**

```
0 2
```

**思路：**先求模式串的左边最大公共前后缀大小，再去做模式匹配。

**注意：**该题主字符串的长度为M,而模式串的长度为N，和上面介绍KMP算法是相反的。

```c++
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;

    int i , j ;
   	//模式串的每个位置的左边最大公共前后缀大小，如果没有的话为0
    ne[1] = 0;//模式串的第一个位置的公共前后缀大小，初始化0
    for  ( j =  2; j <= n ; j++){
        i = ne[j-1];//i保存模式串中j前面位置的最大公共前后缀大小
        while( i > 0 && p[i+1] != p[j] ) i = ne[i];
        if ( p[i+1] == p[j] ) ne[j] = i + 1;
        else ne[j] = 0;
    }

    //主串和模式串匹配
    for (i = 1, j = 0; i <= m; i ++ )
    {
        //发现主串和模式串的元素不相等，则模式串的指针向前回溯
        while ( j && s[i] != p[j+1] ) j = ne[j];
        //主串和模式串的元素相等，则指针都后移
        if ( s[i] == p[j+1] ) j++;
        //模式串和主串中的位置匹配完了，可以输出，并且主串继续后移，模式串继续向前从新的回溯
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}

```

**注意：**该题是输出模式串在主串中所有出现的位置，而不是找模式串第一次出现在主串的位置。

如果是找模式串第一次出现在主串的位置，将主串和模式串匹配改为下面的即可

```c++
    for ( i = 1, j = 0; i <= m; i ++ )
    {
        while ( j && s[i] != p[j+1] ) j = ne[j];
        if ( s[i] == p[j+1] ) j++;
        if (j == n)
        {
            break; 
        }
    }
    if( j == n ) printf("%d ", i - n);
    else printf("NOT FOUND");
```

## 哈希

离散化是一种特殊的哈希。用哈希存储，查找的时间复杂度能大大降低到**O(1)**,这是用空间换时间。

存储结构是以**开放寻址法**或者是**拉链法**

哈希函数：一般都是用 x % 某个素数(一般是数组大小)

一般不需要删除操作，就算有删除操作，我们也并不是真正的删除，而是做一个标记。

### 拉链法：

拉链法是将某个值经过哈希函数后，找到数组对应的下标的链表。数组中的每个单位都是都是单链表

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10;

int h[N], e[N] , ne[N];
int idx = 0  , n;

//插入函数
void insert(int x ){
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}

//查找函数
bool find(int x ){
    int k = (x % N + N) % N;
    for (int  p = h[k] ; p != -1 ;p = ne[p]){
        if( x == e[p]) return true;
    }
    return false;
}




int main(){
    cin >> n;
    memset ( h , -1 , sizeof(h));
    
    while ( n -- ){
        char op[2];
        int x;
        cin >> op >> x;
        if( *op == 'I') insert(x);
        else{
            if(find(x)) cout << "Yes\n";
            else cout << "No\n";
        }
    }
    
    
    return 0;
}
```

**注意：**使用拉链法，h[x]相当于每一个存储x的头指针，初始化h数组的每个值都是-1。

插入操作是将每个链表插入一个头节点。e数组和ne数组是单链表，但是是离散的单链表。分配给哈希函数存储用的。

查找操作是在某个链上查找x，如果找到了返回`true`，如果没找到返回`false`。

### 开放寻址法：

开放寻址法是将所有元素存储在一个数组中，如果经过哈希函数后，该单位已经有值了(即产生了冲突)，那么k++继续找下个位置，如果k==数组的大小，那么让k=0继续找。

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 200003 , null = 0x3f3f3f3f;

int h[N];

int find( int x){
    int k =(x % N + N ) % N;
    
    while( h[k] != null && h[k] != x)
    {
        k++;
        if( k == N) k = 0;
    }
    return k;
}



int main(){
    int n ;
    cin >> n;
    //初始化h
    memset ( h ,0x3f ,sizeof(h));
    
    while ( n -- ){
        char op[2];
        int x , k ;
        cin >> op >> x;
        //如果x存在，返回x在的位置，如果x不存在，则返回x应该在的位置
        k = find(x);
        if( *op == 'I') h[k] = x;
        else{
            if( h[k] == null) cout << "No\n";
            else cout << "Yes\n";
        }
        
    }
    
    
    
    return 0;
}
```

**注意：**开放寻址法和拉链法有区别，find函数去查找x所在的位置，如果x存在，则返回x的位置，如果x不存在，则返回如果插入x的话，x应该在的位置。

1.0x3f3f3f3f作为一个标记表示null。

2.由于x可能是-1，所以进行模运算需要用后面这个公式： k = (x	%	N	+	N)	%	N

3.初始化要用下面的语句，头文件是cstring

```c++
memset ( h , 0x3f , sizeof(h))
```

4.由于可能会有很多冲突，虽然n是1e5但是**开数组要开n的2-3倍大**

## 字符串哈希(重要)

**基本思想：**

h[N]，h数组的每个单元存储的是字符串的哈希值，切h[0]、h[1]、h[2]....h[i]，存储的是字符串长度为i的字符串的哈希值。

例如：字符串ABCDE

h[0] = 0 ;

h[1] = "A";

h[1] = "AB";

h[1] = "ABC";

h[1] = "ABCD";

h[1] = "ABCDE";

**如何计算字符串的哈希值**

1.将字符串看成p进制的数

2.将该p进制的数转换成10进制数后 mod Q，这样就能够将任何数映射成0-Q-1之间的数。

**注意：**

1.不能将某个字符映射成0，这样会引发异常，例如：假如0映射成0，则“0”的哈希值会和“00”的哈希值相等。

2.一般来说**p=131或13331**，**Q=2的64次方**，这样很大概率是不会发生冲突的。

**作用：**

将某个字符串的前缀存储。可以判断其他字符串是否为该字符串的字串。

求字符串的字串[l，r]的哈希值。

已知l-1的哈希值`h[l-1]`和r的哈希值`h[r]`。 计算l到r的哈希值

**h[r]   -  h[l - 1]  *  p <sup>r - l + 1</sup>**

**预处理某个字符串的前缀哈希值**

**h[i] = h[i - 1] * p +str[i];**



acwing.841.字符串哈希

给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

**输入格式**

第一行包含整数n和m，表示字符串长度和询问次数。

第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。

接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。

注意，字符串的位置从1开始编号。

**输出格式**

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。

每个结果占一行。

**数据范围**

1≤n,m≤1051≤n,m≤105

**输入样例：**

```
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

**输出样例：**

```
Yes
No
Yes
```

答案：

```c++
#include <iostream>
using namespace std;

//不需要mod Q，溢出会自动mod
typedef unsigned long long ULL;
const int N = 1e5 + 10, P = 131;

char str[N];
ULL h[N] , p[N];//h数组存哈希值，p数组存p的多少次方
int n , m;

//求字符串字串l到r的哈希值
ULL get(int l ,int r){
    return h[r] - h[l-1] * p[ r - l + 1 ];
}


int main(){
    cin >> n >> m >> str+1;
    
    //预处理h和p
    p[0] = 1;
    for (int i = 1 ;i <= n ; i++){
        p[i] = p[i-1] * P;
        h[i] = h[i-1] * P + str[i];
    }
    
    while ( m-- ){
        int l1, l2 , r1 ,r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if (get(l1,r1) == get(l2, r2)) cout << "Yes\n";
        else cout << "No\n";
    } 
}
```

**总结：**使用h数组存储字符串前缀的哈希值，p数组存储p的多少次方，str字符串是从1开始存储。预处理p数组时，也可以同时预处理h数组。

求该字符串字串的哈希值时间复杂度**O(1)**,

使用字符串哈希解决KMP字符串：

acwing.831.KMP字符串

略题，代码如下：

```c++
#include <iostream>
using namespace  std;

typedef unsigned long long ULL;
const int N = 1e5 + 10 , M = 1e6 + 10, P = 131;

char s[M] , pa[N];
ULL h[M] , p [M];

//求主串的字串的哈希值
ULL get(int l ,int r){
    return h[r] - h[l-1] * p[r - l + 1];
}

int main(){
    int n , m;
    cin >> n >> pa+1 >> m >> s+1;

    //预处理主串和pap
    p[0] = 1;
    for (int i = 1 ; i <= m ; i++){
        p[i] = p[i-1] * P;
        h[i] = h[i-1] * P + s[i];
    }
    
    //计算模式串pa的哈希值
    ULL hP = 0;
    for (int i = 1; i <= n ; i++){
        hP = hP * P + pa[i];
    }
    
    //扫描主串
    for (int i = 1 ; i <= m - n + 1 ;i++){
        if ( get(i,i+n-1) == hP) cout << i - 1 << " ";
    }
  
    
    
    return 0;
}
```

## trie树(字典树)

**可以高效地存储和查找字符串集合的数据结构，也可以用于查询多条字符串中某个字符串出现的次数。**

一般来说，用于字符串只出现字母或者数字的情况。

![image-20201002204731024](https://gitee.com/xddadd/cloud-image/raw/master/image-20201006155731079.png)

一般地，根节点不存储任何数据。

下面是用数组模拟trie树

```c++
const int N = 1e6 + 10;
int son[N][26], cnt[N] , idx;

//插入字符串
void insert(char str[]){
    int p = 0;
    for (int i =  0 ; str[i] ; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u] ;
    }
    cnt[p] ++;
}

//查询某个字符串出现的次数。
int query(char str[]){
    int p = 0 ;
    for (int i = 0 ; str[i] ; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

```

注意：0存储根节点，用idx动态的开辟，cnt[i]存储的字符串最后一个字符存储的结点的次数，如果是0的话，表明没有查询到字符串，`son[i][j]`表示i结点的j儿子的地址，如果该儿子不存在，则为0，这样，用0存储根节点就可以避免这个问题，否则的话要初始化。

acwing.835.Trie字符串统计

```c++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;
int son[N][26], cnt[N] , idx;
char str[N];


void insert(char str[]){
    int p = 0;
    for (int i =  0 ; str[i] ; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u] ;
    }
    cnt[p] ++;
}

int query(char str[]){
    int p = 0 ;
    for (int i = 0 ; str[i] ; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}


int main(){
    int n ;
    cin >> n;
    //n次操作，插入或者查询
    while ( n -- ){
        char op[2];
        cin >> op >> str;
        if( *op == 'I') insert(str);
        else printf("%d\n",query(str));
    }
    return 0;
    
    
}
```

## 并查集

**作用：**

1.将两个集合合并

2.询问两个元素是否在一个集合当中

**实现:**

1.p[i]存储的是i结点的父亲节点的下标，并且默认根节点的父亲节点是自己，即：p[i] = i;

2.初始化的时候，每个结点都看成一个集合。

3.合并将一个集合的根几点的父亲设置为另外一个结点的根节点，即：p[find(a)] = find(b);

4.在查找某个结点的祖宗节点（即所在集合的跟结点）时候，将这条路径的所有结点都设置祖宗节点为父节点，这也叫**路径压缩**。

即：

```c++
int find(int x){
    if( p[x] != x) p[x] = find(p[x]);
    return p[x];
}
```

acwing.836.合并集合

```c++
#include<iostream>
using namespace std;

const int N = 1e5 + 10;

int p[N];
int n , m;


//查找某个结点的祖宗节点(所在集合的根节点的下标)
int find(int x){
    if( p[x] != x) p[x] = find(p[x]);
    return p[x];
}



int main(){
    cin >> n >> m ;
    
    //初始化所有结点，默认每个结点都是一个集合
    for (int i = 1 ; i <= n ; i++) p[i] = i;
    
    
    while ( m -- ){
        char op[2];
        int a, b;
        cin >> op >> a >> b;
        if ( *op == 'M')  p[find(a)] = find(b);//将a结点所在的集合和b结点所在的集合进行合并
        else{
            if(find(a) == find(b)) cout << "Yes\n";
            else cout << "No\n";
        }
    }
    
    return 0;
}
```

**总结：**

以上就两个核心的地方：

1.find()函数，不仅要查找某个结点所在集合的根节点，而且还要进行路径压缩。

2.归并两个结点所在的集合。即27行。

## 堆

堆是一个完全二叉树，用来维护一个数据集合

stl提供的堆默认是大根堆，如果想使用小根堆的话，可以用以下两种方法

1.存储为负数

2.使用下面的语句

```c++
priority_queue<int,vector<int>,greater<int>> heap;
```

**堆的存储**

1.一维数组存储，从1开始，这样任意结点的左儿子为2x，右儿子为2x+1

2.用size来记录堆的大小,heap[]表示堆

**堆的操作**（最小堆为例子）

1.插入一个数**O(logN)**

堆的最后一个位置插入x，然后调整该位置

```c++
heap [++size] = x; up(size);
```

2.求该集合的最小值或者最大值**O(1)**

根节点是最大值或者是最小值

```c++
heap[1];
```

3.删除最小值

最后一个元素覆盖到堆顶，然后调整该元素的位置

```c++
heap[1] = heap[size] ;size -- ；down(1)
```

4.删除任意一个元素

最后一个元素覆盖到该结点，然后调整该元素的位置

```c++
heap[k] = heap[size];size -- ; 
if (heap[size] <= heap[k])  up(k);
else	down(k);
```

5.修改任意一个元素

```c++
heap[k] = x;
if (x <= heap[k])  up[k];
else down(k);
```

**堆的代码实现**

核心两个操作

即：将堆中的某个元素向上调整或者向下调整

```c++
void down(int k ){
	int t = k;
    if (k * 2 <= size && h[k * 2] < h[t]) t = k * 2;
    if (k * 2 + 1 <= size && h[k * 2 + 1] < h[t]) t = k * 2 + 1;
    if (t ！= k){
        sawp(h[k],h[t]);
        down(t);
    }
}
```

```c++
void up(int k ){
    while (k / 2 > 0 && h[k / 2] > h[k]){
        swap(h[k / 2], h[k]);
        k /= 2;
    }
}
```

acwing.838.堆排序

题意：给定一个n,m，然后给定n个整数，输出前m个最小值。

代码

```c++
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int h[N],s;//s表示该堆的大小,即最后一个元素所在的下标



void down(int  k){
    int t = k;
    if ( k * 2 <=s && h[k * 2] < h[t]) t = k * 2;
    if ( k * 2 + 1 <=s && h[k * 2 + 1] < h[t]) t = k * 2 + 1;
    if (t != k){
        swap(h[t],h[k]);
        down(t);
    }
}


int main(){
    int n , m;
    scanf("%d %d ", &n , &m);
    
    //读入
    for (int i = 1; i <= n ; i++){
        scanf("%d",&h[i]);
    }
    s = n;
    
    //将该数组调整进行堆排序调整
    for (int i = n / 2 ; i >=1 ; i--){
        down(i);
    }
    
    while ( m -- ){
        printf("%d ", h[1]);
        h[1] = h[s];
        s -- ;
        down(1);
    }
    
    
    return 0;
}
```

### 堆排序

步骤:

1.将数组调整成堆(从小到大排序用最大堆，从大到小排序用最小堆)

2.执行n次，将堆顶放到最后，忽略堆的最后元素,即堆大小-1，然后继续调整堆

> 为什么从小到大排序用最大堆，从大到小排序用最小堆呢？
>
> 这是根据堆的定义来出发的，如从小到大排序用最大堆。堆中的任意结点k都是比左子树和右子树的所有数大的，但是不能保证同层的结点，从这个性质出发，我们只能保证堆顶是最大的，所以我们直接放到堆的最后面即可。

时间复杂度O(NlogN)，空间复杂度O(1)

### AC代码

```cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int n , m;
int heap[N];
int sz = 0;

//向下调整
void down(int k){
    int t = k;
    if (k * 2 <= sz && heap[k * 2] > heap[t]) t = k * 2;
    if (k * 2 + 1 <= sz && heap[k * 2 + 1] > heap[t]) t = k * 2 + 1;
    if (t != k){
        swap(heap[k], heap[t]);
        down(t);
    }
}

int main(){
    //读入
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i ++) cin >> heap[i];
    sz = n;
    
    //调整成最大堆
    for (int i = n / 2 ; i >= 1 ; i --){
        down(i);
    }
    

    //将堆顶放到最后，调整堆
    for (int i = 1  ; i <= n ; i ++) {
        swap(heap[1], heap[sz]);
        sz --;
        down(1);
    }
    
    //输出前m个数
    for (int i = 1 ; i <= m ; i ++) cout << heap[i] << " ";
    
    return 0;
    
}
```



# 第三章 搜索与图论

## DFS和BSF

DFS(Depth First Search)是深度优先搜索

BFS(Breadth First Search)是宽度优先搜索

![image-20201006155731079](https://gitee.com/xddadd/cloud-image/raw/master/image-20201002204731024.png)

## DFS

### acwing.842.排列数组

给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

**输入格式**

共一行，包含一个整数n。

**输出格式**

按字典序输出所有排列方案，每个方案占一行。

**数据范围**

1≤n≤7

**输入样例**：

```
3
```

**输出样例：**

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

分析：

![image-20201006155952670](https://gitee.com/xddadd/cloud-image/raw/master/image-20201006155952670.png)

![image-20201006160022567](https://gitee.com/xddadd/cloud-image/raw/master/image-20201103232628754.png)

```c++
#include <iostream>
using namespace std;

const int N = 10;

int n;
int path[N];
bool st[N];


void dfs(int  h){
    if (h == n){
        for (int i = 0 ; i < n ; i++) printf("%d ",path[i]);
        printf("\n");
        return;
    }
    
    
    for (int i = 1; i <= n ; i++){
        if(!st[i]){
            path[h] = i;
            st[i] = true;
            //搜索下一层
            dfs(h + 1);
            //回溯，需要将该位复原
            st[i] =false;
        }
    }

}


int main(){
    cin >> n;
    dfs(0);
    return 0;
}
```

### acwing.843.n-皇后问题

![image-20201007200942988](https://gitee.com/xddadd/cloud-image/raw/master/image-20201006160022567.png)





![image-20201103232628754](https://gitee.com/xddadd/cloud-image/raw/master/image-20201007200942988.png)

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 15;

char g[N][N];
int n;
bool col[N], dg[N], udg[N];

void dfs(int h ){
    if ( h == n ){
        for (int i = 0 ; i < n ; i++){
            for (int j = 0 ; j < n ; j++){
                printf("%c",g[i][j]);
            }
            printf("\n");
        }
            
        printf("\n");
        return ;
    }
    
    for (int i = 0 ; i < n ; i++){
        if(!col[i] && !dg[h + i] && !udg[ i - h + n]){
            g[h][i] = 'Q';
            col[i] = dg[h + i] = udg[ i - h + n] =true;
            dfs(h + 1);
            col[i] = dg[h + i] = udg[ i - h + n] =false;
            g[h][i] = '.';
            
        }    
    }
    
}



int main(){
    cin >> n;
    
    for (int i = 0 ; i < n ; i ++)
        for (int j = 0 ; j < n ; j++)
            g[i][j] = '.';
    
    dfs(0);
    return 0 ;
}
```



## BFS

广度优先搜索，最短路问题中，每个点之间的权值如果相等，可以用BFS来解决，如果每个点之间的权值不同的话，用后面的DP动态规划来解决。

### acwing.844.走迷宫

![image-20201007201208449](https://gitee.com/xddadd/cloud-image/raw/master/image-20201007205910554.png)

题意，给定一个矩阵n*m,并且每个都是0 /1，1表示墙，现在问`(0,0)`点到右下角的点`(n-1,m-1)`最短的距离，保证有解，并且每次移动只能上下左右移动。

**解题思路：**利用bfs，并且开个数组记录0,0点到该点的距离，对于每个点的遍历，看看上下左右的四个点，能否走，如果能走的话，能走的点的距离 = 该点的距离 + 1；

```c++
#include <iostream>
#include <queue>
using namespace std;

typedef pair<int,int> PAIR;
const int N = 110;

int g[N][N], s[N][N];//g是题的矩阵，s存该点到0,0点的距离
int n , m;


//返回值是0,0点到右下角点n-1,m-1的距离
int bfs(){
    //初始化s数组，-1表示该点还没被遍历过
    for (int i = 0 ; i < n ; i++)
        for (int j = 0 ; j < m ; j++)
            s[i][j] = -1;
    s[0][0] = 0;//表明该点到自己本身的距离初始化0;
    
    queue<PAIR> q;
    q.push({0,0});//将0,0点放入队列，开始遍历
    
    while (!q.empty()){
        //取出对头
        PAIR t = q.front();
        q.pop();
        
        
        //上右下左移动的偏移量
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        //遍历该点的上下左右的四个点
        for (int i = 0 ; i < 4 ; i++){
            int x = t.first + dx[i], y = t.second + dy[i];
            //如果点合法，并且还没遍历过，而且可以走(0代表可以走，1代表墙)
            if(x >= 0 && x < n && y >= 0 && y < m && s[x][y] == -1 && g[x][y] == 0){
                //距离等于t点距离+1
                s[x][y] = s[t.first][t.second] + 1;
                q.push({x,y});//插入队列
            }
        }
        
    }
    
    
    //返回右下角点到0,0点的距离
    return s[n - 1][m - 1];
    
}



int main(){
    cin >> n >> m;
    //读入n*m的0 1 矩阵
    for (int i = 0; i < n ; i++)
        for (int j = 0 ; j < m ; j++)
            cin >> g[i][j];

    cout << bfs() << endl;
    return 0;
}
```

**思考：**如果需要你输出路径是怎么走的？

**解决：**在这个遍历的基础上，记录下该点是从那个点走来的。最后输出路径的时候，因为每个点记录的是从哪个点走来的，意味着只能找到该点的上一个点，利用一个堆栈，从终点还原并且压栈，最后从堆栈拿出并且输出即可。

## 树和图的存储和遍历

树是一种特殊的图

无向图是一种特殊的有向图，只需要考虑如何遍历有向图。如果需要无向图，则两个结点相连的时候两条边即可。

### 存储

图的存储有两种：邻接矩阵存储和邻接表存储，其中邻接矩阵空间需要N^2^，一般用邻接表来存储

![image-20201007205910554](https://gitee.com/xddadd/cloud-image/raw/master/image-20201007201208449.png)

代码：

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N], e[N], ne[N], idx;


//a与b相连
void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
    
}

//初始化每个结点都是无边的
int main(){
    memset(h , -1 , sizeof(h));
}
```

### 遍历

#### DFS

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N], e[N], ne[N], idx;
bool st[N];//表示哪些点已经遍历过了

//a与b相连
void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void dfs(int u){
    st[u] = true;//标记该点被遍历过了
    
    for (int p = h[u] ; p != -1 ; p =ne[p]){
        int j = e[p];//代表该点指向的点的编号
        if (!st[j]) dfs(j);//如果该点没有被遍历过，就去遍历
    }
    
    
}

int main(){
    memset(h , -1 , sizeof(h));
    
    dfs(0);
}
```

#### DFS例题acwing.846. 树的重心

![image-20201007223139710](https://gitee.com/xddadd/cloud-image/raw/master/image-20201008144920438.png)

**解题思路：**在DFS中，以任意的点为根结点看的话，我们可以在遍历的过程中，求的每个结点一共包含多个结点，即1+子树的结点个数，这需要将该点的子节点遍历后，才能得知。并且我们枚举，假设删除掉该点后，每个连通块的大小是多少，并且从中间取最大值。

枚举删除掉该结点后，每个连通块的大小是多少？

**答：**删除掉该结点后，其他连通块不仅要看该节点字数的最大节点数，还要看该节点上面的连通块的大小，上面的连通块大小为n - sum，sum为该节点即子节点的个数。动态的求max即可。



下面的代码中，sum表示该节点及其下面子节点的个数，res表示去除该节点后，其他连通块的最大节点数，ans表示树的中心，每次得出去掉该节点后连通块的最大节点数后取最小值即可。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10, M = N * 2;

int h[N], e[M] ,ne[M], idx;
int n;
bool st[N];
int ans = N;

void add(int a ,int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int dfs(int u){
    st[u] = true;//表明该结点已经遍历过了
    
    
    int sum = 1, res = 0;
    for (int p = h[u]; p != -1 ; p = ne[p]){
        int j = e[p];
        if (!st[j]){
            int s = dfs(j);
            //该节点包含的节点数=子节点的个数相加
            sum += s;
            //去掉该节点后，子树各自是一个连通块，动态的求这些连通块中的最大值
            res = max(res , s);
        }
    }
    
    //求去除该节点后，该节点上面的连通块的大小
    res = max(res , n - sum);
    
    //更新一下答案
    ans = min(ans, res );
    
    
    return sum;
    
    
}




int main(){
    cin >> n;
    
    memset(h , -1 , sizeof h);
    
    for (int i= 0 ; i < n ; i++){
        int a ,b;
        cin >> a >> b;
        add(a,b);
        add(b,a);
    }
    
    dfs(1);
    
    cout << ans <<endl;
    return 0;
}
```

其中，由于是无向图，dfs从哪个点都可以得到正确的结果。因为结果不是dfs返回的，而是ans一直在更新的。

#### BFS

模板

```c++
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N], e[M], ne[M], idx;
bool st[N];//表示哪些点已经遍历过了

//a与b相连
void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void bfs(int u){
    queue<int> q;
    q.push(u);
    
    while (!q.empty()){
        int t = q.front();
        q.pop();
        if(!st[t]) printf(" %d",t);
        st[t] = true;//该点被遍历过
        
        for (int p = h[t] ; p != -1 ; p = ne[p]){
            int j = e[p];
            if (!st[j]){
                printf(" %d",j);
                st[j] = true;//表明该点被遍历过
                q.push(j);//将该点放入队列中
            }
        }
    }
}

int main(){
    memset(h , -1 , sizeof(h));
    
    bfs(0);
}
```

#### BFS例题acwing.847. 图中点的层次

给定一个n个点m条边的有向图，图中可能存在重边和自环。

所有边的长度都是1，点的编号为1~n。

请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。

**输出格式**

输出一个整数，表示1号点到n号点的最短距离。

**数据范围**

1≤n,m≤1051≤n,m≤105

**输入样例：**

```
4 5
1 2
2 3
3 4
1 3
1 4
```

**输出样例：**

```
1
```

**思路：**这种求最短路问题，并且每条边的权值都是为1，可以用bfs来做。用一个数组s表示1点到每个点的距离，初始化为-1，也代表该点没被遍历过。



代码：

```c++
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N], e[M], ne[M], idx;
int s[N];
int n , m;

void add(int a ,int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}


int bfs(){
    memset(s , -1 ,sizeof s);
    s[1] = 0;//1点到自己的距离为0
    queue<int> q;
    q.push(1);
    
    
    while (!q.empty()){
        int t = q.front();
        q.pop();
        
        for (int p = h[t] ; p != -1 ; p = ne[p]){
            int j = e[p];
            //该点没被遍历过
            if (s[j] == -1){
                s[j] = s[t] + 1;
                q.push(j);//入队
            }
        }
    }
    
    return s[n];
}

int main(){
    cin >> n >> m;
    //邻接表的初始化
    memset(h , -1 , sizeof h);
    
    for (int i  = 0 ; i < m ; i++){
        int a , b;
        cin >> a >> b;
        add(a,b);
    }
    
    cout << bfs() << endl;
    
    return 0;
}
```

## 拓扑排序

BFS的经典应用

拓扑序列是有向无环图

![image-20201008144920438](https://gitee.com/xddadd/cloud-image/raw/master/image-20201007223139710.png)

**入度：**一个点有多少条边指向自己。上图中，3的入度为2

**出度：**该点有多少条边指向其他点。上图中，3的出度为0

由于拓扑序列所有的点都是前面点向后指的，所以入度为0的点作为起点（没有任何点在该点的前面）。

**步骤：**

![image-20201008145728886](https://gitee.com/xddadd/cloud-image/raw/master/image-20201008145728886.png)

- 1.将所有入度为0的点入队。
- 2.如果队列不为空，弹出队头元素。
- 3.对于t的所有的出边t->j,并且删掉t->j，即让j的入度--。
- 4.如果减完之后j的入度=0，就将j这个点入队。
- 5.如果队列一共进了n个点，说明该图是有向无环图，否则，是存在环的一个图，不存在拓扑序列。

**代码：**

```c++
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int h[N], e[M] , ne[M], idx;
int de[N];//表示该点的入度为多少
int n , m;
int top[N], k = 0;//记录top排序的入队序列


void add(int a ,int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}


//如果该图是有向无环图，则进行拓扑排序后返回true，否则返回false
bool topSort(){
    
    queue<int> q;
    //将所有入度为0的点入队
    for (int i = 1; i <= n ; i++){
        if(de[i] == 0){
            q.push(i);
            top[k++] = i;
        }
    }
        
            
    while(!q.empty()){
        int t = q.front();
        q.pop();
        
        for (int p = h[t]; p != -1 ;p = ne[p]){
            int j = e[p];
            de[j] -- ;//删去t->j
            //删去后如果j的入度为0了，则可以入队
            if (de[j] == 0){
                q.push(j);
                top[k++] = j;
            }
        }
    }
    
    //如果所有元素都入过队，则说明该序列是拓扑序列，否则不是
    if (n == k) return true;
    else return false;
    
}

int main(){
    cin >>  n >> m;
    
    memset(h , -1 ,sizeof h);
    
    //读入m条边，并且计算每个点的入度
    for (int i = 0 ; i < m ; i++){
        int a, b;
        cin >> a >> b;
        add(a,b);
        de[b] ++;
    }
    
    //如果该序列是拓扑序列，则输出拓扑排序的结果
    if(topSort()){
        for (int i = 0 ; i < k ; i++){
            printf("%d ",top[i]);
        }
        
    }else{
        printf("-1\n");
    }
    
    
    return 0;
}
```

**注意：**存在拓扑序列不唯一 

## 最短路径问题

最短路问题可以根据以下图的划分。

![image-20201008203657895](https://gitee.com/xddadd/cloud-image/raw/master/image-20201008203657895.png)

上图中，**并不是哪个算法是更好的，只是存在与不同的情况下，用其中的算法**。

专业名词代表的含义：

源点：起点

汇点：终点

单源最短路：只有一个起点，求该点到其他点的最短路

多源汇最短路：多个不同起点到其他点的最短路

稠密图：m = n^2^

系数图：n = m

其中：

朴素版dijkstra适用于m比n大一个级别的，例如：n，m=n^2^。

堆优化版dijkstra适用于n和m都是很大级别的，例如:n和m都是10^5^级别的。

SPFA如果没有限制最多k条边可以用，并且需要无负环。

### 朴素dijskra算法

时间复杂度是O(N^2^)，存储是用邻接矩阵来存储

策略：

![image-20201008224908101](https://gitee.com/xddadd/cloud-image/raw/master/image-20201008224908101.png)

先初始化dis数组里面都为无穷，然后dis[1] = 0,表示1点到自己的距离为0。

然后套一个大的for循环，循环n次，每次先从不确定距离点中找到距离离1最短的点t，找到后将t点标记为确定的点，最后用t点去看1点到其他点的距离，如果1点到t点的距离+t点到连通点j的距离比1点到j点的距离还小，则更新。

#### acWing 849. Dijkstra求最短路 I  

给出n个点，m条边，其中可能重边和自环。求1点到n点的最短距离。

输出

**代码：**

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 510;

int g[N][N];//邻接矩阵
int n , m , dis[N];
bool st[N];

int dijkstra(){
    
    //初始化dis数组
    memset(dis, 0x3f , sizeof dis);
    dis[1] = 0;
    
    
    for (int i = 0 ; i < n ; i++){
        int t = -1;
        //从不确定点中找到距离离1最短的点
        for (int j = 1 ; j <= n ; j++){
            if(!st[j] && (t == -1 || dis[j] < dis[t])){
                t = j;
            }
        }
        st[t] = true;
        
        //用t点去更新其他的点的最短距离
        for (int j = 1 ; j <= n ; j++){
            dis[j] = min(dis[j] , dis[t] + g[t][j]);
        }
    }
    
    //如果n点还是负无穷的话，则说明不连通
    if (dis[n] == 0x3f3f3f3f) return -1;
    else return dis[n];
}


int main(){
    cin >>  n >> m;
    
    memset(g, 0x3f, sizeof g);
    
    for (int i = 0 ; i < m ; i ++){
        int a ,b , c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b] , c);
    }
    
    int ans = dijkstra();
    
    cout << ans << endl;
    
    return 0;    
}

```

**注意：**初始化dis为负无穷是因为我们要更新最短路径，而且要找不确定的点中的到1最短距离的点。

邻接矩阵初始化为负无穷是方便用t点去更新其他点的距离，最后一定要判断1点到n点的距离是否还是无穷，如果是无穷，说明1号点和n号点不连通。

### 堆优化版Dijkstra算法

堆优化版适用于n,m都是一个级别的，例如10^5^级别，所以用邻接表来存储更加的节省空间。

![image-20201009225813719](https://gitee.com/xddadd/cloud-image/raw/master/image-20201009225813719.png)

堆优化版只是将朴素的Dijkstra算法进行了优化，将寻找离t最短路径的不确定的点从之前的`O(N)`优化成了`O(1)`.

**步骤:**

1.初始化

2.从堆中弹出最小路径的点，如果是已经确定的点，继续弹，如果是未确定的点，标记为确定

3.用该点去确定与之相连的其他点的最短路进行更新，并且加入堆。

**时间复杂度：**O(MlogN)

#### acwing.850. Dijkstra求最短路 II

给定n个点m条边的有向图，存在重边和自环，输出1点到n点的最短距离，如果不连通，则输出-1；

n m都是10w级别的

**代码：**

```c++
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

typedef pair<int,int> PAIR;
const int N = 2e5 + 10;

int h[N] , e[N] , ne[N] , w[N], idx; // 邻接矩阵
bool st[N];//记录该点是否已经确定
int n ,m;
int dis[N];

//a到b点权值为c
void add(int a ,int b, int c){
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}


//堆优化版Dijkstra算法
int dijs(){
    priority_queue<PAIR, vector<PAIR>,greater<PAIR> > heap;//最小堆的定义
    //初始化
    memset(dis , 0x3f, sizeof dis);
    dis[1] = 0 ;
    heap.push({0,1});
    
    while (heap.size()){
        auto t = heap.top();
        heap.pop();
        
        int ver = t.second , dist = t.first;
        if(st[ver]) continue;//如果该点已经确定了，就跳过
        st[ver] = true;//该点是未确定点中路径最短的点
        
        
        //用未确定的点更新其他的点
        for (int p = h[ver] ; p != -1 ; p = ne[p]){
            int j = e[p];
            if (dis[ver] + w[p] < dis[j]){
                dis[j] = dis[ver] + w[p];
                heap.push({dis[j], j});
            }
        }
        
        
    }
    
    //如果1和n点不是连通的，返回-1
    if (dis[n] == 0x3f3f3f3f) return -1;
    else return dis[n];
    
}


int main(){
    cin >> n >> m ;
    //初始化邻接表
    memset(h , -1 , sizeof h);
    
    //读入m条边
    for (int i = 0 ;i < m ; i++){
        int a ,b , c;
        cin >> a >> b >> c;
        add(a,b,c);
    }
    
    int ans = dijs();

    cout << ans << endl;
    return 0;
}
```

### Bellman-ford算法

适用于权值为负的情况，并且可以解决**最多k条边到某个点的最短距离**，时间复杂度`O(NM)`。如果有负权回路，并不一定存在最短距离。也可以求得是否存在负权回路的，一般用SPFA来解决。

![image-20201009233728423](https://gitee.com/xddadd/cloud-image/raw/master/image-20201009233728423.png)

其中，可以不用创建邻接矩阵或邻接表，边可以用以下的结构体来存储。

```c++
struct Edge{
    int a ,b , w;
}edges[M];
```

#### acwing.853. 有边数限制的最短路

给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。

注意：图中可能 **存在负权回路** 。

**输入格式**

第一行包含三个整数n，m，k。

接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

**输出格式**

输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。

如果不存在满足条件的路径，则输出“impossible”。

**数据范围**

1≤n,k≤5001≤n,k≤500,
1≤m≤100001≤m≤10000,
任意边长的绝对值不超过10000。

**输入样例**：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

**输出样例：**

```
3
```

**思路：**

初始化后，外面套一层大的for循环k次，每次先将dis数组备份，然后再一个for循环m次，和之前一样的更新dis[j]

例如：

```c++
int bellman_ford(){
    //初始化
    memset(dis , 0x3f , sizeof dis);
    dis[1] = 0;
    
    for (int i = 0 ;i < k ; i++){
        //将dis数组备份
        memcpy(backup , dis , sizeof dis);
        for (int j = 0 ; j < m ; j ++){
            int a = edges[j].a , b = edges[j].b , w = edges[j].w ;
            dis[b] = min(dis[b] , backup[a] + w);//松弛
        }
    }
    
    if(dis[n] > 0x3f3f3f3f / 2) return -1;
    else return dis[n];
}
```

**代码：**

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 510, M = 1e5 + 10;

struct Edge{
  int a , b , w; //a指向b，权值为w
}edges[M];

int n , m , k;
int dis[N] , backup[N];

int bellman_ford(){
    //初始化
    memset(dis , 0x3f , sizeof dis);
    dis[1] = 0;
    
    for (int i = 0 ;i < k ; i++){
        memcpy(backup , dis , sizeof dis);
        for (int j = 0 ; j < m ; j ++){
            int a = edges[j].a , b = edges[j].b , w = edges[j].w ;
            dis[b] = min(dis[b] , backup[a] + w);
        }
    }
    
    if(dis[n] > 0x3f3f3f3f / 2) return -1;
    else return dis[n];
}


int main(){
    cin >> n >> m >> k;
    for (int i = 0 ; i < m ; i ++){
        int a , b , w;
        cin >> a >> b >> w;
        edges[i] = {a,b,w};
    }
    
    int ans = bellman_ford();
    
    if (ans == -1) cout << "impossible";
    else cout << ans ;
    return 0;
}


```

**注意：**由于可能存在串联，需要用backup数组来备份，并且是因为存在负权回路，所以最后的判断不是`==0x3f3f3f3f`，而是dis[n]是一个比较大的数。

### SPFA算法

spfa算法是用队列对bellman_ford算法进行了优化，写起来类似bfs和堆优化版的dijkstra算法，时间复杂度一般O(M)最坏和Bellman_ford算法一样是O(NM)，但是一般情况都比这个快。

spfa算法可以做正权边的题，也可以判断是否存在负环

![image-20201010104805190](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010104805190.png)

需要使用一个st数组来存储该数是否在队列中，队列中存储重复的点没有意义

**思路：**

1.初始化dis,队列，st[1] =true;

2.队列不空的循环

​	弹出对头，设置该点不在队列中

​	更新t的所有邻边

​	如果更新的边没有在队列中，就将该点队列

3.判断dis[n] 是否等于0x3f3f3f3f

**模板：**

```c++
int spfa(){
    //初始化
    memset(dis , 0x3f , sizeof dis);
    dis[1] = 0;
    
    queue<int> q;
    q.push(1);
    st[1] = true;//表明1点在队列中
    
    while(!q.empty()){
        int t = q.front();
        q.pop();
        st[t] = false;//弹出后，标记该点已经不在队列
        
        for (int p = h[t] ; p != -1 ; p = ne[p]){
            int j = e[p];
            //更新t点的邻边
            if(dis[t] + w[p] < dis[j]){
                dis[j] = dis[t] + w[p];
                //更新的点如果没有在队列中，就加入队列，用来更新其他点
                if(st[j] == false){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    //判断是否连通
    if (dis[n] == INF) return INF;
    return dis[n];
}
```

#### acwing.851. spfa求最短路

给定n个点，m条边，可能存在重边和自环，边权为负数，求1点到n点的最短距离，如果不连通，输出impossible，数据保证没有负权回路

n 和 m都是10^5^级别的

**解决思路：**spfa算法

**代码：**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

const int N = 3e5 + 10;

int h[N] , e[N] , ne[N] ,w[N] ,idx;
bool st[N];//st数组标记该元素是否在队列中
int dis[N];
int n , m ;

void add(int a ,int b, int c){
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int spfa(){
    //初始化
    memset(dis , 0x3f , sizeof dis);
    dis[1] = 0;
    
    queue<int> q;
    q.push(1);
    st[1] = true;//表明1点在队列中
    
    while(!q.empty()){
        int t = q.front();
        q.pop();
        st[t] = false;//弹出后，标记该点已经不在队列
        
        for (int p = h[t] ; p != -1 ; p = ne[p]){
            int j = e[p];
            //更新t点的邻边
            if(dis[t] + w[p] < dis[j]){
                dis[j] = dis[t] + w[p];
                //更新的点如果没有在队列中，就加入队列，用来更新其他点
                if(st[j] == false){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    //判断是否连通
    if (dis[n] == 0x3f3f3f3f) return -1;
    return dis[n];
}

int main(){
    cin >> n >> m;
    //初始化邻接表
    memset(h , -1 , sizeof h );
    
    //读入m条边
    for (int i = 0 ; i < m ; i ++){
        int a , b ,c ;
        cin >> a >> b >> c;
        add( a, b ,c);
    }
    
    int ans = spfa();
    
    if(ans == -1 ) cout << "impossible";
    else cout << ans;
}

```

### Floyd算法

Floyd算法是多条查询两点之间的最短距离的问题，时间复杂度O(N^3^).可以有重边或者自环，数据不能存在负权回路

![image-20201010152610648](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010152610648.png)

以上可以用邻接矩阵来存储

```c++
g[a][b]//表示a到b的最短距离
```

**模板：**

```c++
void floyd(){
    for (int k = 1 ; k <= n ; k ++)
        for (int i = 1 ; i <= n ; i++)
            for (int j = 1 ; j <= n ; j++)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
}
```





## 最小生成树

最小生成树一般的问题都是无向图

![image-20201010154048755](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010155632795.png)

一般稠密图用朴素版Prim算法，系数图用Kruskal算法，堆优化版Prim算法很少用。

### 朴素版Prim算法

一般是邻接矩阵来存储，时间复杂度跟朴素版Dijkstra算法一样是O(N^2^)。

![image-20201010155632795](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010154048755.png)

注意：如果所有点不连通，就不存在生成树。

**思路：**

1.初始化所有点到集合的距离为无穷

2.循环n次

​	找到离集合距离最近的点t

​	判断当前t点与集合是否连通，并且将t到集合的距离加到结果中

​	将t点放入集合

​	用t点更新其他点到集合的距离

**模板：**

其中st数组是记录该点是否在集合中

```c++
int prim(){
    //最小生成树的距离
    int res = 0 ;
    初始化
    memset(dis, 0x3f, sizeof dis);
    
    //n次循环
    for (int i = 0 ;i <  n ; i ++){
        int t = -1;
        
        //找不在集合中点中离集合最近的点
        for (int j = 1 ; j <= n ; j++){
            if(!st[j] && (t == -1 || dis[j] < dis[t])){
                t = j;
            }
        }
        
        //说明不连通
        if(i && dis[t] == INF) return INF;
        //将t到集合的距离加到结果中
        if(i) res += dis[t];
        //标记t点在集合中
        st[t] = true;
        
        //用t点来更新其他点到集合的最短距离
        for (int j = 1 ; j <= n ; j++){
            dis[j] = min(dis[j], g[t][j]);
        }
    }
    
    return res;
}
```

### 堆优化版Prim算法

使用堆来维护dis数组，优化了找不在集合中离集合最短距离的点时间复杂度为O(1)。

写起来麻烦，代码较长，如果需要的话，用下面的Kruskal算法

### Kruskal算法

用来处理最小生成树的稀疏图问题，时间复杂度最差O(mlogm),一般情况下表现都很好。因为是枚举每条边，可以用结构来存储边。

![image-20201010163036058](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010204943208.png)

**大概原理：**因为排序后，权值小的在前面，默认所有点不连通的话，这样利用并查集的思想，可以优先将权值小的边去连上。

![image-20201010203826344](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010203826344.png)

**思路：**

1.所有边按权重从小到大排序

2.初始化每个点不连通，类似并查集

3.枚举所有边

​	如果a,b不连通，记录边数和权值之和，a点和b点合并

4.如果总边数 < 总点数 -1 说明图不连通

**模板：**

```c++
//Kruskal算法
int kruskal(){
    //初始化点的并查集，即每个点都是默认不连通的
    for (int i = 1 ; i <= n  ; i++) p[i] = i;
    
    //对所有边按权值从小到大排序
    sort(edges , edges + m , cmp);
    
    int cnt = 0 , res = 0;//cnt表示总边数,ans表示最小生成树的权值之和
    //遍历所有的边
    for (int i = 0 ; i < m ; i ++){
        int a = edges[i].a , b = edges[i].b , w = edges[i].w;
        a = find(a) , b = find(b);
        //判断a和b是否在一个集合中，即是否连通
        if (a != b){
            p[a] = b;
            res += w;
            cnt ++;
        }
    }
    
    //记录的边数 < 点数-1 说明至少存在两个连通集，不满足最小生成树的定义
    if(cnt < n -1) return INF;
    return res;
}
```



#### acwing.859. Kruskal算法求最小生成树

给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。

由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

**数据范围**

1≤n≤1051≤n≤105,
1≤m≤2∗1051≤m≤2∗105,
图中涉及边的边权的绝对值均不超过1000。

**输入样例：**

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

**输出样例：**

```
6
```

**代码：**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10 , INF = 0x3f3f3f3f;

//边，a指向b,权值为w
struct Edge{
    int a , b , w;
}edges[M];
//点
int p[N];
int n , m;

bool cmp(struct Edge a , struct Edge b){
    return a.w < b.w;
}


//并查集的查找祖宗节点，带路径压缩
int find(int a ){
    if (p[a] != a) p[a] = find(p[a]);
    return p[a];
}


//Kruskal算法
int kruskal(){
    //初始化点的并查集，即每个点都是默认不连通的
    for (int i = 1 ; i <= n  ; i++) p[i] = i;
    
    //对所有边按权值从小到大排序
    sort(edges , edges + m , cmp);
    
    int cnt = 0 , res = 0;//cnt表示总边数,ans表示最小生成树的权值之和
    //遍历所有的边
    for (int i = 0 ; i < m ; i ++){
        int a = edges[i].a , b = edges[i].b , w = edges[i].w;
        a = find(a) , b = find(b);
        //判断a和b是否在一个集合中，即是否连通
        if (a != b){
            p[a] = b;
            res += w;
            cnt ++;
        }
    }
    
    //记录的边数 < 点数-1 说明至少存在两个连通集，不满足最小生成树的定义
    if(cnt < n -1) return INF;
    return res;
}


int main(){
    cin >> n >> m;
    
    for (int i = 0; i < m ; i++){
        int a ,b , w;
        cin >> a >> b >> w;
        edges[i] = {a,b,w};
    }
    
    int ans = kruskal();
    
    if (ans == INF) cout << "impossible";
    else cout << ans;
    return 0;
}
```

## 二分图

二分图定义：可以把所有的点划分成两边，使得所有的边都是在这两个集合之间的，集合的内部没有边。

![image-20201010204943208](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010163036058.png)

![image-20201010204514425](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010204514425.png)

### 染色法

可以来**判断该图是否为二分图**，利用了图的一个重要性质：二分图当且仅当图中不含有奇数环，时间复杂度O(N+M)

由于二分图的性质，所以每个点相连的并且没有染色的点，一定和该点染的颜色不相同。

用color[]数组来表示第i个点的状态：即颜色1、颜色2和没染色。

![image-20201010221529093](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010221529093.png)

**实现的步骤：**

1.遍历所有的点

​	如果当前的点没被染色，就调用dfs染色成指定的颜色

​	染色后判断一下dfs染色是否成功，不成功说明该图不是二分图，直接跳出循环

2.dfs的实现，dfs返回bool值，表示染色是否成功，染色不成功说明改图不是二分图。

​	先将u染色成指定的颜色c

​	遍历u的所有邻接点j

​		j如果没有染过色对j进行递归的另外一个颜色的染色，染色后判断染色是否成功

​		j如果染过色但是j的颜色和u的颜色一样，说明不是二分图，直接return

dfs的最后return true 说明整个过程染色都成功。

**具体的模板：**

第一个是循环n个点，第二个是dfs的实现

```c++
   //flag代表染色是否成功
   bool flag;
    for (int i = 1 ; i <= n ; i++){
    	//该点尚未染色，就去染色，并且判断染色是否成功
        if(!color[i]){
            flag = dfs(i , 1);
            if(flag == false) break;
        }
    }
```

dfs的实现

```c++
bool dfs(int u , int c){
    //u染成c颜色
    color[u] = c;
    
    //对于u的所有邻接点j
    for(int p = h[u]; p != -1 ; p = ne[p]){
        int j = e[p];
        //j还没染色，就去染色，并且判断染色是否成功
        if(!color[j]){
            bool flag = dfs(j,3 - c);
            if(flag == false) return false;
        }else if(color[j] == c) return false;//j已经染色了，但是跟u一个颜色，说明非二分图，直接返回
    }
    
    //所有的染色都成功，返回true
    return true;
}
```



#### acWing 860. 染色法判定二分图

给定一个n个点m条边的无向图，图中存在重边和自环。

判断该图是否为二分图。

**大致思路：**

使用DFS进行遍历，并且模拟染色。color数组记录是否染色过、染色颜色。

**代码：**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10 , M = 2e5 + 10;

int h[N], e[M] , ne[M] , idx;
int color[N];
int n , m;

void add(int a ,int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

//返回染色是否成功
bool dfs(int u ,int c){
    //对点u染色c色
    color[u] = c;
    
    //对于u的每个邻接点j
    for (int p = h[u]; p != -1 ; p = ne[p]){
        int j = e[p];
        //j点还未染色，则对j染色，并且判断染色是否成功
        if(!color[j]){
            bool flag = dfs(j , 3 - c);
            if(flag == false) return false;
        }else if(color[j]  != 3 - c) return false;//该点已经染色，但是颜色和u一样，说明矛盾
        
        
    }

    //染色成功
    return true;
}


int main(){
    cin >> n >> m;
    memset(h , -1 , sizeof h);
    
    for (int i = 0 ; i <  m ; i++){
        int a ,b ;
        cin >> a >> b;
        add(a,b) , add(b,a);
    }
    
    //染色
    bool flag;
    for (int i = 1 ; i <= n ; i++){
        //当前的点未被染色，对该点染色，并且返回染色是否成功
        if(!color[i]){
            flag = dfs(i,1);
            if(flag == false) break;
        }
    }
    
    if(flag) cout << "Yes";
    else cout << "No";
    return 0;
}
```



### 匈牙利算法

时间复杂度：邻接矩阵最坏O(N^3^),邻接表最坏O(NM).

![image-20201010222729387](https://gitee.com/xddadd/cloud-image/raw/master/image-20201010222729387.png)

**基本策略：**遍历左边的每个点，对于每个点来说，如果该点能够匹配成功右边的点，就让结果res++，最终输出res即可。

**对于点u的匹配：**

遍历u点的所有邻接点j，

​	如果j还没有被匹配的话，就让u匹配j，如果j点匹配左边的点也没匹配或者让j点左边已经匹配的点再去递归匹配成功的话，u就可以匹配成功j点了，直接return true。

最后return false；

**邻接表实现模板**

左边点的遍历匹配

```c++
    int res = 0;
    for (int  i = 1 ; i <= n1 ; i++){
    	//每次对于左边的点匹配来说，先将右边点都设置未false，表示未匹配
        memset(st ,false ,sizeof st);
        if(find(i)) res ++;
    }
```

核心函数find(u)，返回的是是否匹配成功

```c++
bool find(int u){
    //对于u的每一个邻接点j
    for (int p = h[u] ; p != -1 ; p = ne[p]){
        int j = e[p];
        //j点未被匹配
        if(!st[j]){
            st[j] = true;//设置匹配
            //j点尚未匹配成功 或者 j已经匹配的左边的点重新再匹配成功
            if(match[j] == 0 || find(match[j])){
                match[j] = u;//设置j的匹配的点为u
                return true;//匹配成功
            }
        }
    }
    
    return false;//匹配失败
}
```

**求出二分图的最大匹配数**

给定一个二分图，其中左半部包含n1n1个点（编号1~n1n1），右半部包含n2n2个点（编号1~n2n2），二分图共包含m条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

**输入格式**

第一行包含三个整数 n1n1、 n2n2 和 mm。

接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。

**输出格式**

输出一个整数，表示二分图的最大匹配数。

**数据范围**

1≤n1,n2≤5001≤n1,n2≤500,
1≤u≤n11≤u≤n1,
1≤v≤n21≤v≤n2,
1≤m≤1051≤m≤105

**输入样例**：

```
2 2 4
1 1
1 2
2 1
2 2
```

#### **输出样例**：

```
2
```

**代码：**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510 , M = 2e5  + 10;

int h[N] , e[M] , ne[M] , idx;
int match[N];
int n1, n2 , m ;
bool st[N];

void add(int a ,int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}


bool find(int u){
    //对于u的每一个邻接点j
    for (int p = h[u] ; p != -1 ; p = ne[p]){
        int j = e[p];
        //j点未被匹配
        if(!st[j]){
            st[j] = true;//设置匹配
            //j点尚未匹配成功 或者 j已经匹配的左边的点重新再匹配成功
            if(match[j] == 0 || find(match[j])){
                match[j] = u;//设置j的匹配的点为u
                return true;//匹配成功
            }
        }
    }
    
    return false;//匹配失败
}

int main(){
    cin >> n1 >> n2 >> m;
    memset(h , -1 ,sizeof h);
    
    for (int i = 0 ; i < m ; i++){
        int a ,b ;
        cin >> a >> b;
        add( a,b);
    }
    
    int res = 0;
    for (int  i = 1 ; i <= n1 ; i++){
    	//每次对于左边的点匹配来说，先将右边点都设置未false，表示未匹配
        memset(st ,false ,sizeof st);
        if(find(i)) res ++;
    }
    
    cout << res;
    return 0;
}
```



